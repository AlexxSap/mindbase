#+title: Docker Команды Которые Должен Знать Разработчик

Вам нужно видеть, какие контейнеры =работают= прямо сейчас:
#+begin_src shell
docker ps
#+end_src
Это покажет только живые контейнеры. Но если контейнер упал или его остановили, он исчезнет из списка.

Чтобы увидеть всё, включая =мёртвые=:
#+begin_src
docker ps -a
#+end_src

Самая =частая= команда в разработке:
#+begin_src
docker run -d -p 8080:80 nginx
#+end_src
Разбираем:
-d — запустить в фоне, чтобы терминал не занимался.
-p 8080:80 — проксировать локальный порт 8080 на порт 80 внутри контейнера.
nginx — образ, который запускаем.
Результат: контейнер крутится в фоне, вы можете открыть http://localhost:8080 и увидите nginx.

Контейнер поднялся, поэкспериментировали, теперь нужно его =убить=:
#+begin_src
docker stop имя-или-id
#+end_src
Контейнер остановится, но останется на диске.

Если нужно =удалить= совсем:
#+begin_src
docker rm имя-или-id
#+end_src

Или в один ход — =остановить= и =удалить=:
#+begin_src
docker rm -f имя-или-id
#+end_src
Флаг -f форсирует удаление даже если контейнер работает.

Посмотреть =все= образы у вас на машине:
#+begin_src
docker images
#+end_src

=Удалить= образ, если он вам больше не нужен:
#+begin_src
docker rmi название-образа
#+end_src
Если удалите образ, контейнеры которые на нём основаны, перестанут работать.

Контейнер падает или работает странно? Посмотрите =логи=:
#+begin_src
docker logs имя-или-id
#+end_src
Это покажет всё что контейнер вывел в stdout.

Можно добавить флаг -f чтобы следить в =реальном= времени:
#+begin_src
docker logs -f имя-или-id
#+end_src

Иногда нужно залезть внутрь контейнера и что-то проверить. Откройте =интерактивный= шелл:
#+begin_src
docker exec -it имя-или-id bash
#+end_src
Флаг -it означает интерактивный терминал. Теперь вы внутри, можете запускать команды, смотреть файлы, отлаживать.

Ещё полезно посмотреть =детали= контейнера:
#+begin_src
docker inspect имя-или-id
#+end_src
Будет JSON со всей информацией: какие переменные окружения, какие портами, версии образа, сетевая конфигурация.

Со временем контейнеры и образы накапливаются. =Чистим=:
#+begin_src
docker system prune -a
#+end_src
Это удалит все остановленные контейнеры, все неиспользуемые образы, сети и volumes которые ни на что не ссылаются.

Контейнер падает, данные теряются — такое быть не должно. Для этого есть =тома=:
#+begin_src
docker volume create my_volume
#+end_src

Теперь у вас есть том. Запускаете контейнер и =монтируете= том внутрь:
#+begin_src
docker run -d -v my_volume:/data nginx
#+end_src
Флаг -v монтирует том my_volume в папку /data внутри контейнера. Когда контейнер упадёт, данные в томе остаются. Запустите контейнер снова — данные на месте.

По умолчанию контейнеры могут общаться через IP адреса, но это хрупко. Правильнее создать свою =сеть=:
#+begin_src
docker network create my_network
#+end_src

Теперь =запускаете= контейнеры в этой сети:
#+begin_src
docker run -d --network my_network --name api nginx
docker run -d --network my_network --name db postgres
#+end_src
Контейнеры внутри сети видят друг друга по имени. Это удобнее чем помнить IP адреса.
