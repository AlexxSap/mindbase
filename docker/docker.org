#+title: docker

=Docker= — это платформа, которая предназначена для разработки, развёртывания и запуска приложений в контейнерах.
Он позволяет отделить приложения от инфраструктуры и управлять инфраструктурой по аналогии с тем, как мы управляем приложениями.
=Docker= предоставляет возможность упаковывать и запускать приложение в слабо изолированной среде - =контейнере=. Изоляция и безопасность позволяют одновременно запускать несколько контейнеров на одном хосте (хостом может быть наша локальная машина, дата центр, облачный провайдер или их микс).
=Контейнеры= являются легковесными и содержат все необходимое для запуска приложения, что избавляет нас от необходимости полагаться на то, что установлено на хосте.

* Для чего Docker может использоваться?
+ Быстрая и согласованная доставка приложений
  =Docker= рационализирует жизненный цикл разработки, позволяя разработчикам работать в стандартизированной среде через локальные контейнеры, предоставляющие приложения и сервисы. =Контейнеры= отлично подходят для рабочих процессов непрерывной интеграции и непрерывной доставки (continuous integration/continuous delivery, CI/CD).

+ Отзывчивая разработка и масштабирование
  Платформа, основанная на =контейнерах=, позволяет легко портировать приложения. =Контейнеры= могут запускаться на локальной машине разработчика, в физических или виртуальных дата-центрах, облачных провайдерах или смешанных средах.

+ Запуск большего количества приложений на одной машине
  =Docker= является легковесным и быстрым. Он предоставляет работоспособную и экономичную альтернативу виртуальным машинам на основе гипервизора, что позволяет использовать больше вычислительных мощностей для решения аналогичных задач.

* Архитектура Docker
=Docker= использует клиент-серверную архитектуру. =Клиент= (=Docker client=) обращается к =демону= (=Docker daemon=), который поднимает (собирает), запускает и распределяет =контейнеры=. Клиент и демон могут быть запущены в одной системе или клиент может быть подключен к удаленному демону. Клиент и демон общаются через =REST API= поверх UNIX-сокетов или сетевого интерфейса. Другим клиентом является =Docker Compose=, позволяющий работать с приложениями, состоящими из нескольких контейнеров.

** Демон
=Демон= (=dockerd=) регистрирует (слушает) запросы, поступающие от =Docker API=, и управляет такими объектами как образы, контейнеры, сети и тома. Демон может общаться с другими демонами для управления сервисами.

** Клиент
=Клиент= (=docker=) - основной способ коммуникации с =Docker=. При выполнении такой команды, как =docker run=, клиент отправляет эту команду демону, который, собственно, эту команду и выполняет. Команда =docker= использует =Docker API=. Клиент может общаться с несколькими демонами.

** Docker Desktop
=Docker Desktop= - это десктопное приложение для Mac, Windows и Linux, позволяющее создавать и распределять контейнерные приложения и микросервисы. =Docker Desktop= включает в себя демона, клиента, Docker Compose, Docker Content Trust, Kubernetes и Credential Helper.

** Реестр
В =реестре= (=registry=) хранятся образы контейнеров. =Docker Hub= - это публичный реестр, который (по умолчанию) используется =Docker= для получения образов. Имеется возможность создания частных (закрытых) реестров.
При выполнении таких команд, как =docker pull= или =docker run=, необходимые образы загружаются из настроенного реестра. А при выполнении команды =docker push= образ загружается в реестр.

* Объекты
При использовании =Docker= мы создаем и используем =образы=, =контейнеры=, =сети=, =тома=, =плагины= и другие объекты. Рассмотрим некоторые из них.
** Образы (Images)
=Образ= - это доступный только для чтения шаблон с инструкциями по созданию контейнера. Часто образ представляет собой модификацию другого образа.
Можно создавать свои образы или использовать образы, созданные другими и опубликованные в =реестре=. Для создания образа используется =Dockerfile=, содержащий инструкции по созданию образа и его запуску (см. ниже). Ряд инструкций в =Dockerfile= приводит к созданию в образе нового =слоя= (раньше новый слой создавался для каждой инструкции). При изменении =Dockerfile= и повторной сборке образа пересобираются только модифицированные слои. Это делает образы легковесными, маленькими и быстрыми.

** Контейнеры (Containers)
=Контейнер= - это запускаемый =экземпляр образа=. Мы создаем, запускаем, перемещаем и удаляем контейнеры с помощью =Docker API= или =CLI= (command line interface, интерфейс командной строки). Мы можем подключать контейнеры к сетям, добавлять в них хранилища данных и даже создавать новые образы на основе текущего состояния.
По умолчанию контейнеры хорошо =изолированы= от других контейнеров и хоста. Однако мы можем управлять тем, насколько изолированы сеть, хранилище данных или другая подсистема контейнера.
Контейнер определяется образом и настройками, указанными при его создании и запуске. При удалении контейнера его состояние также удаляется. Этого можно избежать с помощью хранилища данных.

* Команды и флаги
** docker run
Команда =docker run= используется для запуска контейнера. Это основная и потому наиболее часто используемая команда.
#+begin_verse
# сигнатура
docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]
# основные настройки (флаги)
-d - запуск контейнера в качестве отдельного процесса
-p - публикация открытого порта в интерфейсе хоста (HOST:CONTAINER)
# например
-p 3000:3000
-t - выделение псевдотерминала
-i - оставить STDIN открытым без присоединения к терминалу
--name - название контейнера
--rm - очистка системы при остановке/удалении контейнера
--restart - политика перезапуска - no (default) | on-failure[:max-retries] | always | unless-stopped
-e - установка переменной среды окружения
-v - привязка распределенной файловой системы (name:/path/to/file)
# например
-v mydb:/etc/mydb
-w - установка рабочей директории
#+end_verse

** docker build
Команда =docker build= используется для создания образа на основе файла =Dockerfile= и =контекста=.
=Контекст= - это набор файлов, находящихся в локации, определенной с помощью =PATH= или =URL=.
=PATH= - это директория в нашей локальной системе, а =URL= - это удаленный репозиторий. =Контекст= сборки обрабатывается рекурсивно, поэтому =PATH= включает как директорию, там и все ее поддиректории, а =URL= - как репозиторий, так и все его субмодули.
Для исключения файлов из сборки образа используется =.dockerignore= (синтаксис этого файла похож на =.gitignore=).
#+begin_verse
# сигнатура
docker build [OPTIONS] PATH | URL | -
#+end_verse

Создание образа:
#+begin_verse
# в качестве контекста сборки используется текущая директория
docker build .
#+end_verse

Использование репозитория в качестве контекста (предполагается, что =Dockerfile= находится в корневой директории репозитория):
#+begin_verse
docker build github.com/creack/docker-firefox
#+end_verse

#+begin_verse
docker build -f ctx/Dockerfile http://server/ctx.tar.gz
#+end_verse
В данном случае http://server/ctx.tar.gz отправляется демону, которые загружает и извлекает файлы. Параметр =-f ctx/Dockerfile= определяет путь к =Dockerfile= внутри =ctx.tar.gz=.

Чтение =Dockerfile= из =STDIN= без контекста:
#+begin_verse
docker build - < Dockerfile
#+end_verse

Добавление тега к образу:
#+begin_verse
docker build -t myname/my-image:latest .
#+end_verse

Определение =Dockerfile=:
#+begin_verse
docker build -f Dockerfile.debug .
#+end_verse

Экспорт файлов сборки в директорию =out=:
#+begin_verse
docker build -o out .
#+end_verse

Экспорт файлов сборки в файл =out.tar=:
#+begin_verse
docker build -o - . > out.tar
#+end_verse

** docker exec
Команда =docker exec= используется для выполнения команды в запущенном контейнере.
#+begin_verse
# сигнатура
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
# основные флаги
-d - выполнение команды в фоновом режиме
-e - установка переменной среды окружения
-i - оставить `STDIN` открытым
-t - выделение псевдотерминала
-w - определение рабочей директории внутри контейнера
#+end_verse

Пример:
#+begin_verse
# -U - это пользователь, которым по умолчанию является root
docker exec -it postgres psql -U postgres
#+end_verse

** docker ps
Команда =docker ps= используется для получения списка (по умолчанию только запущенных) контейнеров.

#+begin_verse
# сигнатура
docker ps [OPTIONS]
# основные флаги
-a - показать все контейнеры (как запущенные, так и остановленные)
-f - фильтрация вывода на основе условия (`id`, `name`, `status` и т.д.)
-n - показать n последних созданных контейнеров
-l - показать последний созданный контейнер
# пример получения списка приостановленных контейнеров
docker ps -f 'status=paused'
#+end_verse

Для получения списка образов используется команда =docker images=.

** Команды управления

# запуск остановленного контейнера
docker start CONTAINER

# приостановление всех процессов, запущенных в контейнере
docker pause CONTAINER

# остановка контейнера
docker stop CONTAINER

# "убийство" контейнера
docker kill CONTAINER

# перезапуск контейнера
docker restart CONTAINER

# удаление остановленного контейнера
docker rm [OPTIONS] CONTAINER
# основные флаги
-f - принудительное удаление (остановка и удаление) запущенного контейнера
-v - удаление анонимных томов, связанных с контейнером
# пример удаления всех остановленных контейнеров
docker rm $(docker ps --filter status=exited -q)

# удаление образа
docker rmi IMAGE

# управление образами
docker image COMMAND

# управление контейнерами
docker container COMMAND

# управление томами
docker volume COMMAND

# управление сетями
docker network COMMAND

# управление docker
docker system COMMAND

** Другие команды
Для получения логов запущенного контейнера используется команда =docker logs=:

docker logs [OPTIONS] CONTAINER
# основные флаги
-f - следование за выводом
-n - n последних строк

Для удаления всех неиспользуемых данных (контейнеры, сети, образы и, опционально, тома) используется команда =docker system prune=. Основные флаги:

-a - удаление всех неиспользуемых образов, а не только обособленных (dangling)
--volumes - удаление томов

*Предостережение*: применять эту команду следует с крайней осторожностью, поскольку удаленные данные не подлежат восстановлению.

[[https://docs.docker.com/reference/cli/docker/][Полный список команд и флагов.]]
