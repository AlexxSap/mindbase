#+title: docker

=Docker= — это платформа, которая предназначена для разработки, развёртывания и запуска приложений в контейнерах.
Он позволяет отделить приложения от инфраструктуры и управлять инфраструктурой по аналогии с тем, как мы управляем приложениями.
=Docker= предоставляет возможность упаковывать и запускать приложение в слабо изолированной среде - =контейнере=. Изоляция и безопасность позволяют одновременно запускать несколько контейнеров на одном хосте (хостом может быть наша локальная машина, дата центр, облачный провайдер или их микс).
=Контейнеры= являются легковесными и содержат все необходимое для запуска приложения, что избавляет нас от необходимости полагаться на то, что установлено на хосте.

* Для чего Docker может использоваться?
+ Быстрая и согласованная доставка приложений
  =Docker= рационализирует жизненный цикл разработки, позволяя разработчикам работать в стандартизированной среде через локальные контейнеры, предоставляющие приложения и сервисы. =Контейнеры= отлично подходят для рабочих процессов непрерывной интеграции и непрерывной доставки (continuous integration/continuous delivery, CI/CD).

+ Отзывчивая разработка и масштабирование
  Платформа, основанная на =контейнерах=, позволяет легко портировать приложения. =Контейнеры= могут запускаться на локальной машине разработчика, в физических или виртуальных дата-центрах, облачных провайдерах или смешанных средах.

+ Запуск большего количества приложений на одной машине
  =Docker= является легковесным и быстрым. Он предоставляет работоспособную и экономичную альтернативу виртуальным машинам на основе гипервизора, что позволяет использовать больше вычислительных мощностей для решения аналогичных задач.

* Архитектура Docker
=Docker= использует клиент-серверную архитектуру. =Клиент= (=Docker client=) обращается к =демону= (=Docker daemon=), который поднимает (собирает), запускает и распределяет =контейнеры=. Клиент и демон могут быть запущены в одной системе или клиент может быть подключен к удаленному демону. Клиент и демон общаются через =REST API= поверх UNIX-сокетов или сетевого интерфейса. Другим клиентом является =Docker Compose=, позволяющий работать с приложениями, состоящими из нескольких контейнеров.

** Демон
=Демон= (=dockerd=) регистрирует (слушает) запросы, поступающие от =Docker API=, и управляет такими объектами как образы, контейнеры, сети и тома. Демон может общаться с другими демонами для управления сервисами.

** Клиент
=Клиент= (=docker=) - основной способ коммуникации с =Docker=. При выполнении такой команды, как =docker run=, клиент отправляет эту команду демону, который, собственно, эту команду и выполняет. Команда =docker= использует =Docker API=. Клиент может общаться с несколькими демонами.

** Docker Desktop
=Docker Desktop= - это десктопное приложение для Mac, Windows и Linux, позволяющее создавать и распределять контейнерные приложения и микросервисы. =Docker Desktop= включает в себя демона, клиента, Docker Compose, Docker Content Trust, Kubernetes и Credential Helper.

** Реестр
В =реестре= (=registry=) хранятся образы контейнеров. =Docker Hub= - это публичный реестр, который (по умолчанию) используется =Docker= для получения образов. Имеется возможность создания частных (закрытых) реестров.
При выполнении таких команд, как =docker pull= или =docker run=, необходимые образы загружаются из настроенного реестра. А при выполнении команды =docker push= образ загружается в реестр.

* Объекты
При использовании =Docker= мы создаем и используем =образы=, =контейнеры=, =сети=, =тома=, =плагины= и другие объекты. Рассмотрим некоторые из них.

** Образы (Images)
=Образ= - это доступный только для чтения шаблон с инструкциями по созданию контейнера. Часто образ представляет собой модификацию другого образа.
Можно создавать свои образы или использовать образы, созданные другими и опубликованные в =реестре=. Для создания образа используется =Dockerfile=, содержащий инструкции по созданию образа и его запуску (см. ниже). Ряд инструкций в =Dockerfile= приводит к созданию в образе нового =слоя= (раньше новый слой создавался для каждой инструкции). При изменении =Dockerfile= и повторной сборке образа пересобираются только модифицированные слои. Это делает образы легковесными, маленькими и быстрыми.

** Контейнеры (Containers)
=Контейнер= - это запускаемый =экземпляр образа=. Мы создаем, запускаем, перемещаем и удаляем контейнеры с помощью =Docker API= или =CLI= (command line interface, интерфейс командной строки). Мы можем подключать контейнеры к сетям, добавлять в них хранилища данных и даже создавать новые образы на основе текущего состояния.
По умолчанию контейнеры хорошо =изолированы= от других контейнеров и хоста. Однако мы можем управлять тем, насколько изолированы сеть, хранилище данных или другая подсистема контейнера.
Контейнер определяется образом и настройками, указанными при его создании и запуске. При удалении контейнера его состояние также удаляется. Этого можно избежать с помощью хранилища данных.

* Команды и флаги
** docker run
Команда =docker run= используется для запуска контейнера. Это основная и потому наиболее часто используемая команда.
#+begin_src
# сигнатура
docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]
# основные настройки (флаги)
-d - запуск контейнера в качестве отдельного процесса
-p - публикация открытого порта в интерфейсе хоста (HOST:CONTAINER)
# например
-p 3000:3000
-t - выделение псевдотерминала
-i - оставить STDIN открытым без присоединения к терминалу
--name - название контейнера
--rm - очистка системы при остановке/удалении контейнера
--restart - политика перезапуска - no (default) | on-failure[:max-retries] | always | unless-stopped
-e - установка переменной среды окружения
-v - привязка распределенной файловой системы (name:/path/to/file)
# например
-v mydb:/etc/mydb
-w - установка рабочей директории
#+end_src

** docker build
Команда =docker build= используется для создания образа на основе файла =Dockerfile= и =контекста=.
=Контекст= - это набор файлов, находящихся в локации, определенной с помощью =PATH= или =URL=.
=PATH= - это директория в нашей локальной системе, а =URL= - это удаленный репозиторий. =Контекст= сборки обрабатывается рекурсивно, поэтому =PATH= включает как директорию, там и все ее поддиректории, а =URL= - как репозиторий, так и все его субмодули.
Для исключения файлов из сборки образа используется =.dockerignore= (синтаксис этого файла похож на =.gitignore=).
#+begin_src
# сигнатура
docker build [OPTIONS] PATH | URL | -
#+end_src

Создание образа:
#+begin_src
# в качестве контекста сборки используется текущая директория
docker build .
#+end_src

Использование репозитория в качестве контекста (предполагается, что =Dockerfile= находится в корневой директории репозитория):
#+begin_src
docker build github.com/creack/docker-firefox
#+end_src

#+begin_src
docker build -f ctx/Dockerfile http://server/ctx.tar.gz
#+end_src
В данном случае http://server/ctx.tar.gz отправляется демону, которые загружает и извлекает файлы. Параметр =-f ctx/Dockerfile= определяет путь к =Dockerfile= внутри =ctx.tar.gz=.

Чтение =Dockerfile= из =STDIN= без контекста:
#+begin_src
docker build - < Dockerfile
#+end_src

Добавление тега к образу:
#+begin_src
docker build -t myname/my-image:latest .
#+end_src

Определение =Dockerfile=:
#+begin_src
docker build -f Dockerfile.debug .
#+end_src

Экспорт файлов сборки в директорию =out=:
#+begin_src
docker build -o out .
#+end_src

Экспорт файлов сборки в файл =out.tar=:
#+begin_src
docker build -o - . > out.tar
#+end_src

** docker exec
Команда =docker exec= используется для выполнения команды в запущенном контейнере.
#+begin_src
# сигнатура
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
# основные флаги
-d - выполнение команды в фоновом режиме
-e - установка переменной среды окружения
-i - оставить `STDIN` открытым
-t - выделение псевдотерминала
-w - определение рабочей директории внутри контейнера
#+end_src

Пример:
#+begin_src
# -U - это пользователь, которым по умолчанию является root
docker exec -it postgres psql -U postgres
#+end_src

** docker ps
Команда =docker ps= используется для получения списка (по умолчанию только запущенных) контейнеров.

#+begin_src
# сигнатура
docker ps [OPTIONS]
# основные флаги
-a - показать все контейнеры (как запущенные, так и остановленные)
-f - фильтрация вывода на основе условия (`id`, `name`, `status` и т.д.)
-n - показать n последних созданных контейнеров
-l - показать последний созданный контейнер
# пример получения списка приостановленных контейнеров
docker ps -f 'status=paused'
#+end_src

Для получения списка образов используется команда =docker images=.

** Команды управления
#+begin_src
# запуск остановленного контейнера
docker start CONTAINER

# приостановление всех процессов, запущенных в контейнере
docker pause CONTAINER

# остановка контейнера
docker stop CONTAINER

# "убийство" контейнера
docker kill CONTAINER

# перезапуск контейнера
docker restart CONTAINER

# удаление остановленного контейнера
docker rm [OPTIONS] CONTAINER
# основные флаги
-f - принудительное удаление (остановка и удаление) запущенного контейнера
-v - удаление анонимных томов, связанных с контейнером
# пример удаления всех остановленных контейнеров
docker rm $(docker ps --filter status=exited -q)

# удаление образа
docker rmi IMAGE

# управление образами
docker image COMMAND

# управление контейнерами
docker container COMMAND

# управление томами
docker volume COMMAND

# управление сетями
docker network COMMAND

# управление docker
docker system COMMAND
#+end_src
** Другие команды
Для получения логов запущенного контейнера используется команда =docker logs=:
#+begin_src
docker logs [OPTIONS] CONTAINER
# основные флаги
-f - следование за выводом
-n - n последних строк
#+end_src
Для удаления всех неиспользуемых данных (контейнеры, сети, образы и, опционально, тома) используется команда =docker system prune=. Основные флаги:
#+begin_src
-a - удаление всех неиспользуемых образов, а не только обособленных (dangling)
--volumes - удаление томов
#+end_src

*Предостережение*: применять эту команду следует с крайней осторожностью, поскольку удаленные данные не подлежат восстановлению.

[[https://docs.docker.com/reference/cli/docker/][Полный список команд и флагов.]]

* Dockerfile
=Dockerfile= - это документ (без расширения), содержащий инструкции, которые используются для создания образа при выполнении команды =docker build=.
*Предостережение:* не используйте / в качестве =PATH= для контекста сборки. Это приведет к передаче демону всего содержимого жесткого диска вашей машины.
Инструкции выполняются по одной. Результаты наиболее важных инструкций фиксируются в виде отдельных слоев образа. Обратите внимание: каждая инструкция выполняется независимо от других. Это означает, что выполнение =RUN cd /tmp= не будет иметь никакого эффекта для последующих инструкций.

=Dockerfile= может содержать следующие инструкции:
#+begin_src
# Комментарий
ИНСТРУКЦИЯ аргументы

# Основные
# FROM - родительский образ
FROM <image>[:<tag>] [AS <name>]
# пример
FROM node:12-alpine AS build

# WORKDIR - установка рабочей директории для инструкций RUN, CMD, ENTRYPOINT, COPY и ADD
WORKDIR /path/to/dir
# пример
WORKDIR /app

# COPY - копирование новых файлов или директорий из <src>
# и их добавление в файловую систему образа по адресу, указанному в <dest>
COPY <src> <dest>
COPY ["<src>", "<dest>"]
# пример
COPY package.* yarn.lock ./
# или
COPY . .
# ADD, в отличие от COPY, позволяет копировать удаленные файлы,
# а также автоматически распаковывает сжатые (identity, gzip, bzip2 или xz) локальные файлы

# ADD - копирование новых файлов, директорий или удаленного (!) файла из <src>
# и их добавление в файловую систему образа по адресу, указанному в <dest>
ADD <src> <dest>
ADD ["<src>", "<dest>"]
# пример
ADD some.txt some_dir/ # <WORKING_DIR>/some_dir/

# RUN - выполнение команды в новом слое на основе текущего образа и фиксация результата
RUN <command>
# или
RUN ["executable", "arg1", "arg2"] # Кавычки должны быть двойными
# пример
RUN npm install

# CMD - предоставление дефолтных значений исполняемому контейнеру
CMD ["executable", "arg1", "arg2"]
# или если данной инструкции предшествует инструкция ENTRYPOINT
CMD ["arg1", "arg2"]
# или
CMD command arg1 arg2
# пример
CMD [ "node", "/app/src/index.js" ]
# RUN выполняет команду и фиксирует результат,
# CMD ничего не выполняет во время сборки, а определяет команду для образа
# (!) выполняется только одна (последняя) инструкция CMD

# ENTRYPOINT - настройка исполняемого контейнера
ENTRYPOINT ["executable", "arg1", "arg2"]
ENTRYPOINT command arg1 arg2
# пример
ENTRYPOINT ["top", "-b"]
CMD ["-c"]
# docker run -it --rm --name test top -H
# top -b -H
# разница между ENTRYPOINT и CMD:
# https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact
# https://stackoverflow.com/questions/21553353/what-is-the-difference-between-cmd-and-entrypoint-in-a-dockerfile

# переменные
# ${var} или $var
# пример
FROM busybox
ENV FOO=/bar
WORKDIR ${FOO}    # WORKDIR /bar
ADD . $FOO        # ADD . /bar
COPY \$FOO /qux   # COPY $FOO /qux

# Другие
# LABEL - добавление метаданных к образу
LABEL <key>=<value>
# пример
LABEL version="1.0"

# EXPOSE - информация о сетевом порте, прослушиваемом контейнером во время выполнения
EXPOSE <port> | <port>/<protocol>
# пример
EXPOSE 3000

# ENV - установка переменных среды окружения
ENV <key>=<value>
# пример
ENV MY_NAME="No Name"

# VOLUME - создание точки монтирования
VOLUME ["/var/log"]
VOLUME /var/log

# USER - установка пользователя для использования при запуске контейнера
# в любых инструкциях RUN, CMD и ENTRYPOINT
USER <user>[:<group>]
USER <UID>[:<GID>]

# ARG - определение переменной, которая может быть передана через командную строку при
# выполнении команды `docker build` с помощью флага `--build-arg <name>=<value>`
ARG <name>[=<default value>]

# ONBUILD - добавление в образ триггера, запускаемого при использовании
# данного образа в качестве основы для другой сборки
ONBUILD <INSTRUCTION>
#+end_src

[[https://docs.docker.com/reference/dockerfile/][Справка по Dockerfile]]

* Рекомендации по Dockerfile
Рассмотрим следующий =Dockerfile=:
#+begin_src
# syntax=docker/dockerfile:1
FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py
#+end_src

Выполнение каждой инструкции (кроме =CMD=) из этого файла приводит к созданию нового слоя:
+ =FROM= создает слой из образа =ubuntu:18.04=
+ =COPY= добавляет файлы из текущей директории
+ =RUN= собирает приложение с помощью make
+ =CMD= определяет команду для запуска приложения в контейнере
При запуске образа и генерации контейнера мы добавляем новый слой, доступный для записи, поверх остальных. Все изменения в запущенном контейнере, такие как создание новых файлов, их модификация или удаление записываются в этот слой.

** Создание эфемерных контейнеров
Генерируемые контейнеры должны быть максимально эфемерными. Под эфемерностью понимается возможность остановки, уничтожения, повторной сборки и замены контейнеров без необходимости дополнительной настройки процесса их генерации.

** Понимание контекста сборки
При выполнении команды =docker build= контекстом сборки, как правило, является текущая директория. Предполагается, что =Dockerfile= находится в этой директории. Путь к =Dockerfile=, находящемуся в другом месте, можно указать с помощью флага -f. Независимо от того, где находится =Dockerfile=, все файлы и директории из текущей директории отправляются демону в качестве контекста сборки.

В следующем примере мы
+ создаем (=mkdir=) директорию =myapp=, которая используется в качестве контекста сборки
+ переходим в нее (=cd=)
+ создаем файл =hello= с текстом "hello"
+ создаем =Dockerfile=, читающий (=cat=) содержимое файла =hello=
+ собираем образ с тегом =helloapp:v1=
#+begin_src
mkdir myapp && cd myapp
echo "hello" > hello
echo -e "FROM busybox\nCOPY /hello /\nRUN cat /hello" > Dockerfile
docker build -t helloapp:v1 .
#+end_src

Размещаем =Dockerfile= и =hello= в разных директориях и собираем вторую версию образа без использования кеша предыдущей сборки (-f определяет путь к =Dockerfile=):
#+begin_src
# создаем директории
mkdir -p dockerfiles context
# перемещаем файлы
mv Dockerfile dockerfiles && mv hello context
# собираем образ
docker build --no-cache -t helloapp:v2 -f dockerfiles/Dockerfile context
#+end_src

** .dockerignore
В файле =.dockerignore= указываются файлы, не имеющие отношения к сборке и поэтому не включаемые в нее. Синтаксис =.dockerignore= похож на синтаксис =.gitignore= или =.npmignore=.

** Многоэтапная сборка
Многоэтапная сборка позволяет существенно уменьшить размер финального образа без необходимости изучения процесса сборки на предмет наличия промежуточных слоев и файлов, которые можно удалить.
Если процесс сборки состоит из нескольких слоев, мы можем упорядочить их от редко модифицируемых до часто модифицируемых:
+ установка инструментов, необходимых для сборки приложения
+ установка или обновление зависимостей
+ генерация приложения

Пример =Dockerfile= для Go-приложения:
#+begin_src
# syntax=docker/dockerfile:1
FROM golang:1.16-alpine AS build

# устанавливаем инструменты
# выполняем `docker build --no-cache .` для обновления зависимостей
RUN apk add --no-cache git
RUN go get github.com/golang/dep/cmd/dep

# список зависимостей из `Gopkg.toml` и `Gopkg.lock`
# эти слои будут собираться повторно только при изменении файлов `Gopkg`
COPY Gopkg.lock Gopkg.toml /go/src/project/
WORKDIR /go/src/project/
# устанавливаем зависимости
RUN dep ensure -vendor-only

# копируем проект и собираем его
# этот слой будет собираться повторно только при изменении файлов из директории `project`
COPY . /go/src/project/
RUN go build -o /bin/project

# получаем образ, состоящий из одного слоя
FROM scratch
COPY --from=build /bin/project /bin/project
ENTRYPOINT ["/bin/project"]
CMD ["--help"]
#+end_src

** Лишние библиотеки
Для уменьшения сложности, количества зависимостей и времени сборки следует избегать установки дополнительных и ненужных библиотек "на всякий случай".

** Разделение приложений
Каждый контейнер должен иметь одну ответственность (=single responsibility=).
Разделение приложений на несколько контейнеров облегчает горизонтальное масштабирование и переиспользуемость контейнеров.
Например, стек веб-приложения может состоять из 3 отдельных контейнеров, каждый со своим уникальным образом, для управления приложением, базы данных и сервера или распределенного кеша, хранящегося в памяти. Если контейнеры зависят друг от друга для обеспечения возможности их коммуникации следует использовать сети.

** Минимизация количества слоев
В старых версиях =Docker= каждая инструкция в =Dockerfile= приводила к созданию нового слоя. Сейчас новые слои создаются только инструкциями =RUN=, =COPY= и =ADD=. Другие инструкции создают временные промежуточные образы, которые не приводят к увеличению размера сборки.

** Сортировка многострочных аргументов
Многострочные аргументы рекомендуется сортировать в алфавитном порядке. Также рекомендуется добавлять пробел перед обратным слэшем (\).
Пример:
#+begin_src
RUN apt-get update && apt-get install -y \
 bzr \
 cvs \
 git \
 mercurial \
 subversion \
 && rm -rf /var/lib/apt/lists/*
#+end_src

** Использование кеша сборки
При сборке образа =Docker= изучает все инструкции в порядке, определенном в =Dockerfile=. После изучения инструкции =Docker= обращается к своему кешу. Если в кеше имеется соответствующий образ, новый образ не создается. Для сборки образа без обращения к кешу используется настройка =--no-cache=true=.

* Рекомендации по инструкциям
** FROM
В качестве основы для создания образа рекомендуется использовать официальные образы из =DockerHub= версии =alpine=.

** LABEL
Подписи позволяют структурировать образы проекта, добавлять информацию о лицензиях, могут использоваться для автоматизации и т.д.
#+begin_src
# одна подпись
LABEL com.example.version="0.0.1-beta"
# несколько подписей
LABEL vendor=ACME\ Incorporated \
     com.example.is-beta= \
     com.example.is-production="" \
     com.example.version="0.0.1-beta" \
     com.example.release-date="2021-01-12"
#+end_src

** RUN
Длинные и сложные инструкции =RUN= рекомендуется разделять на несколько строк с помощью обратного слэша (\). Это делает =Dockerfile= более читаемым, облегчает его понимание и поддержку.
#+begin_src
RUN apt-get update && apt-get install -y \
   package-bar \
   package-baz \
   package-foo  \
   && rm -rf /var/lib/apt/lists/*
#+end_src

** CMD
Инструкция =CMD= используется для запуска программ в контейнере вместе с аргументами.
=CMD= должна использоваться в форме =CMD ["executable", "param1", "param2"]=. В большинстве случаев первым элементом должен быть интерактивный терминал, такой как =bash=, =python= или =perl=. Например, =CMD ["perl", "-de0"]=, =CMD ["python"]= или =CMD ["php", "-a"]=. При использовании =ENTRYPOINT= следует убедиться, что пользователи понимают, как работает эта инструкция.

** EXPOSE
Инструкция =EXPOSE= определяет порты, на которых контейнер регистрирует соединения. Рекомендуется использовать порты, которые являются традиционными для приложения. Например, образ, содержащий веб-сервер =Apache=, должен использовать =EXPOSE 80=, а образ, содержащий =MongoDB= - =EXPOSE 27017=.

** ENV
Для облегчения запуска программы можно использовать =ENV= для обновления переменной среды окружения =PATH= для приложения, устанавливаемого контейнером. Например, =ENV PATH=/usr/local/nginx/bin:$PATH= обеспечивает, что =CMD ["nginx"]= просто работает.
Инструкция =ENV= также может быть полезна для предоставления обязательных для сервиса переменных, таких как =PGDATA= для =Postgres=.
Наконец, =ENV= может использоваться для установки номеров версий, что облегчает их обновление.

** ADD или COPY
Хотя =ADD= и =COPY= имеют похожий функционал, в большинстве случаев следует использовать =COPY=, поскольку эта инструкция является более прозрачной, чем =ADD=. =COPY= поддерживает копирование в контейнер только локальных файлов, а =ADD= также позволяет извлекать файлы из локальных архивов и получать файлы по =URL=, но вместо последнего лучше использовать =curl= или =wget=: это позволяет удалять ненужные файлы после извлечения.
Если =Dockerfile= состоит из нескольких этапов, на которых используются разные файлы из контекста, эти файлы рекомендуется копировать индивидуально. Это позволяет обеспечить инвалидацию кеша только для модифицированных файлов.
Например:
#+begin_src
COPY package.json /app
RUN npm i
# предполагается, что директория node_modules указана в .dockerignore
COPY . /app
#+end_src

** ENTRYPOINT
=ENTRYPOINT= определяет основную команду для образа, что позволяет запускать образ без этой команды.
Рассмотрим пример образа для инструмента командной строки =s3cmd=:
#+begin_src
ENTRYPOINT ["s3cmd"]
CMD ["--help"]
#+end_src

Данный образ может быт запущен следующим образом:
#+begin_src
docker run s3cmd
#+end_src
Это приведет к выводу справки.

Либо мы может передать параметры для выполнения команды:
#+begin_src
docker run s3cmd ls s3://mybucket
#+end_src
Это может быть полезным при совпадении названия образа со ссылкой на исполняемый файл.

** VOLUME
Инструкция =VOLUME= следует использовать для доступа к любой области хранения базы данных, хранилищу настроек или файлам/директориям, созданным контейнером. Крайне не рекомендуется использовать =VOLUME= для мутабельных и/или пользовательских частей образа.

** WORKDIR
Для ясности и согласованности для =WORKDIR= всегда следует использовать абсолютные пути. Также =WORKDIR= следует использовать вместо инструкций типа =RUN cd ... && do-something=, которые трудно читать, отлаживать и поддерживать.
