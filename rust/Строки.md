В ядре Rust есть только один тип строки: срез строки `str`, который обычно виден в своей заимствованной форме `&str`. Строковые литералы хранятся в двоичном файле программы, таким образом, они являются срезами строк. 

Тип `String`, предоставляемый стандартной библиотекой Rust, представляет собой расширяемый, изменяемый, собственный строковый тип в кодировке UTF-8.

Создание новой строки
```rust
let mut s = String::new();
```
Часто мы хотим начать строку с некоторых начальных данных. Для этого мы используем метод to_string:

```rust
let data = "initial contents";
let s = data.to_string();
let s = "initial contents".to_string();
```

Мы также можем использовать функцию `String::from` для создания `String` из строкового литерала.

```rust
let s = String::from("initial contents");
```

### Обновление строки

String может увеличиваться в размере и его содержимое может меняться. Мы можем использовать оператор `+` или макрос `format!` для объединения значений `String`.

Использование оператора `+`:

```rust
let s1 = String::from("Привет, ");
let s2 = String::from("мир!");
let s3 = s1 + &s2; // s3 содержит "Привет, мир!"
```

Использование макроса `format!`

```rust
let s1 = String::from("Привет");
let s2 = String::from("мир");
let s3 = format!("{} {}", s1, s2); // s3 содержит "Привет мир"
```

Мы можем увеличивать `String`, используя метод `push_str`:

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

После этого `s` будет содержать `foobar`.

### Индексация строк в Rust

Во многих языках программирования строки поддерживают индексацию, но в Rust попытка обратиться к строке по индексу вызовет ошибку.

```rust
let s1 = String::from("hello");
let h = s1[0];
```

Этот код приведет к ошибке, потому что строки в Rust не поддерживают индексацию.

Внутреннее представление строк

Строки в Rust представлены как обертка над `Vec<u8>`. Это значит, что строка "Hola" занимает 4 байта памяти (по 1 байту на символ), но строка "Здравствуйте" занимает 24 байта, так как каждый символ занимает 2 байта в кодировке UTF-8.

### Срезы строк

Хотя прямое индексирование строк недопустимо, в Rust можно создавать срезы строк с помощью диапазонов. Например, `&hello[0..4]` даст нам срез строки "Здравствуйте", содержащий первые 4 байта или "Зд".

Но если срез извлечет не все байты символа - будет panic, пример `&hello[..3]` то есть 2-й байт не является границей символа д в данном примере.

### Методы для итерации по строкам

Чтобы работать с частями строк, лучше всего явно указывать, хотите ли вы работать с символами или байтами.

1) Метод chars возвращает отдельные символы.

```rust
for c in "Зд".chars() {
    println!("{c}");
}

===================
З
д
```


2) Метод bytes возвращает отдельные байты.

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
===================
208
151
208
180
```

### Вывод:

Rust делает корректную обработку строк по умолчанию, что может казаться сложным, но предотвращает ошибки, связанные с не-ASCII символами.

Стандартная библиотека Rust предоставляет множество функций для работы со строками, помогая обрабатывать сложные ситуации правильно.