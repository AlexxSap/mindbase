
В Rust модуль `std::marker` содержит различные маркерные трейты, которые предоставляют информацию о свойствах типов и помогают компилятору принимать решения о безопасности и оптимизациях кода. Вот несколько основных маркерных трейтов из этого модуля:

1. `Copy`: Этот трейт указывает, что тип может быть клонирован путем копирования его байтов. Типы, реализующие этот трейт, копируются при присваивании или передаче в качестве аргументов функций.

2. `Send`: Этот трейт указывает, что значение типа можно безопасно передавать между потоками. Реализация этого трейта позволяет передавать объекты типа через границы потоков безопасным способом.

3. `Sync`: Этот трейт указывает, что значение типа может быть безопасно разделяемым между несколькими потоками. Если тип реализует этот трейт, то он безопасен для одновременного доступа из нескольких потоков.

4. `Sized`: Этот трейт указывает, что размер типа известен на этапе компиляции. Большинство типов в Rust по умолчанию являются Sized, и компилятор автоматически добавляет это ограничение к ним.

5. `Unpin`: Этот трейт указывает, что тип можно безопасно перемещать после того, как он был закреплен. В контексте `async/await` и `futures` `Unpin` играет важную роль в разрешении и избежании некоторых ограничений в конкурентном программировании.

Давайте рассмотрим пример с маркерным трейтом `Copy`. Трейт `Copy` указывает, что тип можно безопасно копировать по значению. Допустим, у нас есть структура `Point`:

```rust
#[derive(Debug, Copy, Clone)]
struct Point {
    x: f64,
    y: f64,
}

fn main() {
    let original_point = Point { x: 2.0, y: 3.0 };

    // После этой строки `original_point` все еще остается доступным и не перемещается.
    let copied_point = original_point;

    println!("Original Point: {:?}", original_point);
    println!("Copied Point: {:?}", copied_point);
}
```


Здесь структура `Point` реализует `Copy` и `Clone`. После создания оригинальной точки (`original_point`) мы можем создать ее копию (`copied_point`) с помощью простого присваивания. 

Трейт `Copy` позволяет этой операции произойти без перемещения данных, и обе точки остаются доступными для использования.