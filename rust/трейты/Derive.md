Компилятор способен предоставлять базовые реализации для некоторых трейтов с помощью атрибута `#[derive]`. Эти трейты все еще могут быть реализованы вручную, если требуется более сложное поведение.

Вот список трейтов, которые можно производить:

- Трейты сравнения: `Eq`, `PartialEq`, `Ord`, `PartialOrd`.
- `Clone`, чтобы создать `T` из `&T` путем копирования.
- `Copy`, чтобы предоставить типу "семантику копирования" вместо "семантики перемещения".
- `Hash`, чтобы вычислить хэш из `&T`.
- `Default`, чтобы создать пустой экземпляр типа данных.
- `Debug`, чтобы форматировать значение с использованием форматтера `{:?}`.

1. `Debug`
Для удобства отладки вы можете автоматически реализовать трейт `Debug`, чтобы легко выводить значения ваших структур в консоль.
```rust
#[derive(Debug)]
struct Point {
      x: i32,
      y: i32,
}


let point = Point { x: 10, y: 20 };
println!("{:?}", point); // Выводит "Point { x: 10, y: 20 }"
```

2. `Clone` и `Copy`:
```rust
#[derive(Debug, Clone)]
struct Company {
   name: String,
   ceo: String,
}

let company1 = Company {
   name: "ExampleCorp".to_string(),
   ceo: "Alice Example".to_string(),
};

// Создаем глубокую копию company1
let company2 = company1.clone();

println!("Оригинал: {:?}", company1);
println!("Клон: {:?}", company2);
```

В этом примере `Company` реализует трейт `Clone`, что позволяет создавать глубокие копии экземпляров `Company` с использованием метода `clone`.

```rust
#[derive(Debug, Copy, Clone)]
struct Point {
   x: i32,
   y: i32,
}

let point1 = Point { x: 0, y: 0 };

// Создаем копию point1 с помощью побитового копирования
let point2 = point1; // Нет необходимости вызывать метод clone явно

println!("Оригинал: {:?}", point1);
println!("Копия: {:?}", point2);
```

Здесь `Point` реализует и `Copy`, и `Clone`. Поскольку `Point` содержит только примитивные типы данных, которые сами по себе являются `Copy`, мы можем сделать `Point` также `Copy`. Это позволяет компилятору автоматически копировать `Point` при присваивании, без необходимости явного вызова `clone`.

Важное замечание: когда тип реализует `Copy`, его значения копируются при любых операциях присваивания, и оригинальное значение остается доступным после копирования. Это отличается от типов, реализующих только `Clone`, где оригинал может быть "заимствован" и потому не доступен после клонирования, если используется перемещение вместо клонирования.