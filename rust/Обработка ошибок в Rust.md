
В Rust нет исключений. Вместо этого Rust использует тип `Result<T, E>` для восстанавливаемых ошибок и макрос `panic!`, который останавливает выполнение программы при обнаружении невосстанавливаемой ошибки.

В Rust ошибки делятся на две категории:

- Невосстанавливаемые ошибки: Ошибки, при которых программа должна немедленно завершиться. В Rust для таких случаев используется макрос `panic!`.

```rust
fn drink(beverage: &str) {
    // Вы не должны пить слишком много сладких напитков.
    if beverage == "lemonade" { panic!("AAAaaaaa!!!!"); }

    println!("Some refreshing {} is all I need.", beverage);
}

fn main() {
    drink("water");
    drink("lemonade");
}
```

Чтобы увидеть трейс используйте переменную `RUST_BACKTRACE=1`.

- Восстанавливаемые ошибки: Ошибки, которые можно обработать, например, когда файл не найден. Здесь Rust предоставляет тип `Result<T, E>`, который позволяет явно возвращать успешный результат или информацию об ошибке.

```rust
fn parse_number(s: &str) -> Result<i32, std::num::ParseIntError> {
	s.parse::<i32>()
}

fn main() {
	let nember_str = "123d";
	let result = parse_number(number_str);

	match result {
		Ok(n) => println!("Число {}", n),
		Err(r) => println!("Ошибка {}", e),
	}
}
```

В этом примере функция `parse_number` пытается разобрать строку как `i32`. Если это удается, она возвращает `Ok` со значением числа. Если происходит ошибка, она возвращает `Err` с описанием ошибки.