В Rust итераторы играют ключевую роль в обработке коллекций данных. Два часто используемых метода для создания итераторов — это `iter()` и `into_iter()`. На первый взгляд они могут показаться похожими, но на самом деле они служат разным целям и имеют важные различия.

### iter()

Метод `iter()` создает итератор, который заимствует элементы коллекции. Это означает, что при итерации с `iter()`, элементы коллекции остаются неизменными, и итератор возвращает ссылки на элементы. Это идеально подходит, когда вам нужно прочитать данные из коллекции, не владея ими.

```rust
let vec = vec![1, 2, 3, 4];

for value in vec.iter() {
    println!("{}", value);
}

// Вектор vec остается доступным для использования после итерации
println!("vec is still here: {:?}", vec);
```


### into_iter()

В отличие от `iter()`, метод `into_iter()` создает итератор, который потребляет (или "забирает") коллекцию, на которой он вызван, и возвращает владение элементами. Используйте `into_iter()`, когда вам нужно преобразовать коллекцию в итератор и вам не нужен доступ к оригинальной коллекции после этого.

```rust
let vec = vec![1, 2, 3, 4];

for value in vec.into_iter() {
    println!("{}", value);
}

// Вектор vec больше недоступен; следующая строка вызовет ошибку компиляции
// println!("vec is gone: {:?}", vec);
```


### Когда использовать что?

- Используйте `iter()`, когда вам нужно сохранить коллекцию после итерации или когда вам нужны только ссылки на элементы.
- Выбирайте `into_iter()` для полного потребления коллекции и получения владения её элементами, особенно если предполагается их изменение или перемещение.

Понимание различий между `iter()` и `into_iter()` поможет вам писать более эффективный и идиоматичный код на Rust. Экспериментируйте с ними и используйте наиболее подходящий в зависимости от вашего конкретного случая использования! 