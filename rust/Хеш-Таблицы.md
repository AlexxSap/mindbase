Хеш-таблицы, представленные как `HashMap<K, V>`, сохраняют отображение ключей типа K на значения типа V. Основное использование: поиск данных с помощью ключей, а не индексов. 

- Создание Хеш-Таблицы:

Для создания используйте `new` и добавляйте элементы с `insert`.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```

Примечание: HashMap не в прелюдии, поэтому вы должны указать ее путь. Кроме того, ей не хватает некоторой поддержки стандартной библиотеки, например, встроенных макросов.

Хеш-таблицы хранят данные в куче, имеют ключи  и значения и являются гомогенными структурами данных, то есть ключи и значения должны быть одного типа данных.

- Доступ к Значениям:

Получите значения с помощью метода get и ключа.

```rust
let score = scores.get(&team_name).copied().unwrap_or(0);
```

Перебор хеш-таблицы может быть выполнен аналогично векторам.

```rust
for (key, value) in &scores {
        println!("{key}: {value}");
}
```

- Хеш-Таблицы и Владение:

1) Для типов с Copy значения копируются в хеш-таблицу.
2) Для сложных типов значения перемещаются, и хеш-таблица становится владельцем.

- Обновление Хеш-Таблицы:

Для того чтобы перезаписать значение, просто используйте ключ, который уже находится в хеш-таблице.

```rust
let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25); // Перезаписывает предыдущее значение 10
```

- Добавление ключа и значения только если ключ отсутствует:

```rust
scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(10); // Это не изменит значение для "Blue", так как оно уже существует
```

- Обновление значения на основе старого значения:

```rust
let team_name = String::from("Blue");
let score = scores.entry(team_name).or_insert(0);
*score += 10; // Увеличиваем значение на 10
```

- Функции Хеширования:

По умолчанию: `SipHash` - устойчив к атакам DoS, но не самый быстрый алгоритм.
При необходимости можно указать другой хешер (тип, реализующий трейт `BuildHasher`).