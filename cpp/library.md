[back](./lessons.md)

# Library
разные прикольные и не очень фичи из обновления стандартной библиотеки

### std::span

позволяет ссылаться (не владеющая ссылка) на любую последовательность значений типа `T`
Преимущество `std::span` заключается в том, что он содержит информацию о количестве элементов данных. Таким образом, не нужен дополнительный параметр под размер массива. Еще можно сделать его из подпоследовательности и много чего еще.
Так же есть `std::mdspan` - позволяет представить последовательность в виде многомерной последовательности.
В принципе как итераторы, но удобнее. 
НО для контейнеров есть серьёзные ограничения. Например: работает с вектором и массивом, но не работает со списком, деком, множеством.

### std::source_location

Замена макросов `__LINE__` и `__FILE__`. Может выдать имя текущего файла, функции, строку и колонку. Удобно использовать в логировании.

### std::format и std::format_to

Наконец-то сборка строк по формату добралась до крестов. 
В качестве первого аргумента функция принимает строку форматирования. Эта строка содержит любое количество плейсхолдеров {}. Второй и последующие параметры представляют аргументы, которые вставляются в эти плейсхолдеры - внутрь фигурных скобок - по одному аргументу для каждой пары фигурных скобок.
`std::format_to` - отправляет сформированную строку куда-то по итератору.

```cpp
    std::cout << std::format("{} + {} = {}", a, b, a+b);
```
 
Так же есть возможность указать спецификаторы формата: 
- порядок
```cpp
    int a{10};
    int b{20};
    int c{30};
    std::cout << std::format("{2:} {1:} {0:}", a, b, c);    // 30 20 10
```

- количество знаков
```cpp
    double sum {100.2567}; 
    std::cout << std::format("sum = {:.5}", sum); // sum = 100.26
```

- количество знаков после запятой
```cpp
    std::cout << std::format("sum = {:.5f}", sum); // sum = 100.25670
```

- ширину вывода
```cpp
    int a {2}; 
    int b {5};
    int c {-8};
    std::cout << std::format("a = {:07}", a) << std::endl; // a = 0000002
    std::cout << std::format("b = {:7}", b) << std::endl; //  b =       5
    std::cout << std::format("c = {:07}", c) << std::endl; // c = -000008
```

- так же птичим языком - выравнивание, настройку типа

### std::print and std::println

Интегрировано с std::format

Было:
```cpp
std::cout << std::format("{} apples", 5);
```

Стало:
```cpp
std::print("{} apples", 5);
```

Стало удобнее.


### flat containers

Четыре новых ассоциативных контейнера: `std::flat_map`, `std::flat_multimap`, `std::flat_set` и `std::flat_multiset`, которые являются полноценной заменой упорядоченных ассоциативных контейнеров `std::map`, `std::multimap`, `std::set` и `std::multiset`. 

Особенности плоских ассоциативных контейнеров:
- Временная и пространственная сложность отличаются от упорядоченных контейнеров. Они требуют меньше памяти и быстрее считываются. 
- Поддерживают итератор с произвольным доступом. 
- Обеспечивают непрерывное пространство памяти для хранения элементов, что улучшает доступ к кешу и значительно уменьшает количество обращений к распределителю памяти. 

Офигенская штука (вроде). Можно будет выкинуть abseil и qt-шные QSet/QHash, потому что памяти они занимает чудовишьно много.

НО пока нет компилятора, в которых они поддерживаются.

### std::expected

шаблон класса, который предоставляет способ представления одного из двух значений: ожидаемого типа `T` или неожиданного типа `E`. 

Параметры шаблона:
`T` — тип ожидаемого значения.
`E` — тип ошибки. Он должен соответствовать требованиям разрушаемости и быть допустимым аргументом шаблона для `std::unexpected` (не допускаются массивы, необъектные типы и cv-квалифицированные типы). 
`std::expected` задумывался как один из вариантов обработки ошибок. В отличие от исключений, он даёт дополнительный выигрыш в производительности, а также освобождает программиста от рутинных задач. 

При использовании этого типа можно либо попробовать достать значение, либо запросить о том, какое там значение ошибки. 

Пример:
```cpp
enum class MathError : unsigned char
{
    ZeroDivision,
    NegativeNotAllowed
};

std::expected<int, MathError> Bar(int a, int b)
{
    if (b == 0)
    {
        return std::unexpected(MathError::ZeroDivision);
    }
    if (a < 0 || b < 0)
    {
        return std::unexpected(MathError::NegativeNotAllowed);
    }
    return a / b;
}

int main()
{
    std::expected<int, MathError> foo = Bar(1, 3);
  
    if (foo.has_value())
    {
        std::cout << *foo;
    }
    else if (foo.error() == MathError::ZeroDivision)
    {
        std::cout << "Divided by zero";
    } 
    else if (foo.error() == MathError::NegativeNotAllowed)
    {
        std::cout << "Negative numbers not allowed";
    }
}
```

