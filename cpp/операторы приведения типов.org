#+title: Операторы Приведения Типов

В C++ существует четыре оператора приведения типов, каждый из которых предназначен для определённых целей:

* static_cast
Используется для безопасного и предсказуемого приведения типов, выполняемого во время компиляции.
Приведение между совместимыми типами (например, int → double).
Преобразование указателей в пределах одной иерархии классов (безопасно вниз и вверх по иерархии).
Преобразование void* в указатель на конкретный тип.
#+begin_src cpp
double d = 3.14;
int i = static_cast<int>(d); // Преобразование double -> int

void* ptr = &i;
int* intPtr = static_cast<int*>(ptr); // Преобразование void* -> int*
#+end_src

* dynamic_cast
Используется для безопасного приведения указателей/ссылок в иерархии классов при наличии виртуальных функций (т.е. для полиморфных классов).
Безопасное приведение вниз по иерархии (от базового класса к производному).
Проверка приведения во время выполнения (если преобразование невозможно, dynamic_cast вернёт nullptr для указателей или вызовет исключение для ссылок).
#+begin_src cpp
class Base {
    virtual void foo() {} // Наличие виртуальной функции делает класс полиморфным
};

class Derived : public Base {};

Base* b = new Derived();
Derived* d = dynamic_cast<Derived*>(b); // Безопасное приведение вниз по иерархии
if (d) {
    std::cout << "Приведение успешно!\n";
} else {
    std::cout << "Ошибка приведения\n";
}
#+end_src

* const_cast
Позволяет добавлять или убирать модификатор const у переменных.
Используется в случаях, когда нужно изменить константные данные (например, при работе со старыми API, где функция принимает неконстантный указатель).
Опасен, если реально изменить const-объект (это приводит к неопределённому поведению).
#+begin_src cpp
void print(int* ptr) {
    *ptr = 42; // Меняем значение
}

const int num = 10;
print(const_cast<int*>(&num)); // Снимаем const
#+end_src

* reinterpret_cast
Используется для низкоуровневого преобразования типов, которое меняет битовое представление данных.
Преобразование между несвязанными типами (например, указателя в int).
Опасен, так как не гарантирует корректность результата.
#+begin_src cpp
int num = 65;
char* ptr = reinterpret_cast<char*>(&num); // Интерпретация int как массив байтов
std::cout << *ptr << '\n'; // Выведет 'A' (ASCII-код 65)
#+end_src
