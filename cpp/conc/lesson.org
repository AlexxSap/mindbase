#+title: Многопоточность на С++

ссылка на [[https://en.cppreference.com/w/cpp/thread][cppreference]]

* Конкурентность и параллелизм
=Конкурентность= означает, что несколько задач выполняются одновременно, но не обязательно одновременно на физическом уровне (на разных процессорах или ядрах). Задачи могут быть переключены между собой, чтобы дать иллюзию одновременного выполнения.
=Параллелизм= означает фактическое одновременное выполнение нескольких задач на разных физических ресурсах, таких как множество процессоров или ядер в многоядерной системе. При использовании параллелизма, задачи действительно выполняются одновременно и могут значительно увеличить производительность приложения.
Основное отличие между =конкуренцией= и =параллелизмом= заключается в том, что конкуренция описывает способность системы обрабатывать множество задач одновременно, независимо от физического параллелизма.

* Процесс и поток
=Поток= — это процедура выполнения на процессоре (в рамках какого-то =процесса=) набора инструкций, программного кода. Его назначение — параллельное выполнение на процессоре двух или более различных задач. Все =потоки= в =процессе= разделяют его адресное пространство.
=Процесс= — это абстракция, которая инкапсулирует в себе все ресурсы процесса и их дескрипторы, потоки и т.д. Каждый процесс имеет как минимум один поток.

* std::execution
Единый фреймворк асинхронности и параллелизма.
В С++26 обещают развить это во что-то [[https://en.cppreference.com/w/cpp/execution][страшно большое]] . Но сейчас есть только работа этой штуки в алгоритмах на коллекциях.

Есть 4 варианта:
 + =seq= - std::execution::sequenced_policy - это default поведение. Алгоритм не должен быть параллелизован или векторизован библиотекой.
 + =par= - std::execution::parallel_policy - эта политика объявляет, что вызов алгоритма безопасен от race condition и deadlock (или как мне прикольно перевёл яндекс гпт =расовых условий и мёртвых замков=). Поэтому библиотека может параллелизовать алгоритм (но не может векторизовать).
 + =par_unseq= - std::execution::parallel_unsequenced_policy - эта политика объявляет, что вызов алгоритма можно векторизовать. Это значит, что тело функции можно запускать для нескольких значений одновременно в том же потоке.
 + =unseq= - std::execution::unsequenced_policy - эта политика объединяет гарантии политик =par= и =unseq= и должна обеспечивать наивысший уровень оптимизации.

Так вот оно указывается:
#+begin_src cpp
std::for_each(std::execution::par, std::begin(container), std::end(container), [](){...});
#+end_src

*НО* указание параллельной политики НЕ гарантирует параллельное выполнение, так как решение зависит от реализации и runtime-среды.
[[./exec_pol/main.cpp][жми сюда]]

* Потоки
** std::tread
** threads managing

* Атомики
** std::atomic
** atomic operations

* Синхронизация выполнения
** mutual exclusion
** condition variables
** semaphores
** futures
** каналы
* Частые ошибки
* Векторизация
