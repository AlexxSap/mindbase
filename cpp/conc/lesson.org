#+title: Многопоточность на С++

ссылка на [[https://en.cppreference.com/w/cpp/thread][cppreference]]

* Конкурентность и параллелизм
=Конкурентность= означает, что несколько задач выполняются одновременно, но не обязательно одновременно на физическом уровне (на разных процессорах или ядрах). Задачи могут быть переключены между собой, чтобы дать иллюзию одновременного выполнения.
=Параллелизм= означает фактическое одновременное выполнение нескольких задач на разных физических ресурсах, таких как множество процессоров или ядер в многоядерной системе. При использовании параллелизма, задачи действительно выполняются одновременно и могут значительно увеличить производительность приложения.
Основное отличие между =конкуренцией= и =параллелизмом= заключается в том, что конкуренция описывает способность системы обрабатывать множество задач одновременно, независимо от физического параллелизма.

* Процесс и поток
=Поток= — это процедура выполнения на процессоре (в рамках какого-то =процесса=) набора инструкций, программного кода. Его назначение — параллельное выполнение на процессоре двух или более различных задач. Все =потоки= в =процессе= разделяют его адресное пространство.
=Процесс= — это абстракция, которая инкапсулирует в себе все ресурсы процесса и их дескрипторы, потоки и т.д. Каждый процесс имеет как минимум один поток.

* std::execution
Единый фреймворк асинхронности и параллелизма.
В С++26 обещают развить это во что-то [[https://en.cppreference.com/w/cpp/execution][страшно большое]] . Но сейчас есть только работа этой штуки в алгоритмах на коллекциях.

Есть 4 варианта:
 + =seq= - std::execution::sequenced_policy - это default поведение. Алгоритм не должен быть параллелизован или векторизован библиотекой.
 + =par= - std::execution::parallel_policy - эта политика объявляет, что вызов алгоритма безопасен от race condition и deadlock (или как мне прикольно перевёл яндекс гпт =расовых условий и мёртвых замков=). Поэтому библиотека может параллелизовать алгоритм (но не может векторизовать).
 + =par_unseq= - std::execution::parallel_unsequenced_policy - эта политика объявляет, что вызов алгоритма можно векторизовать. Это значит, что тело функции можно запускать для нескольких значений одновременно в том же потоке.
 + =unseq= - std::execution::unsequenced_policy - эта политика объединяет гарантии политик =par= и =unseq= и должна обеспечивать наивысший уровень оптимизации.

Так вот оно указывается:
#+begin_src cpp
std::for_each(std::execution::par, std::begin(container), std::end(container), [](){...});
#+end_src

*НО* указание параллельной политики НЕ гарантирует параллельное выполнение, так как решение зависит от реализации и runtime-среды.
[[./exec_pol/main.cpp][жми сюда]]

* Потоки
** std::tread
Основной класс для создания новых потоков в C++ – это =std::thread=.
+ Объект класса представляет собой один поток выполнения.
+ Новый поток начинает выполнение сразу же после построения объекта =std::thread=.
+ Возвращаемое значение функции потока, а если в ней будет брошено исключение, которое не будет обработано в этом же потоке, то вызовется =std::terminate=.
+ Передать возвращаемое значение или исключение из нового потока наружу можно через =std::promise= или через глобальные переменные.
+ Объекты =std::thread= также могут быть не связаны ни с каким потоком (после =default construction=, =move from=, =detach= или =join=), и поток выполнения может быть не связан ни с каким объектом =std::thread= (после =detach=).
+ Никакие два объекта =std::thread= не могут представлять один и тот же поток выполнения; =std::thread= нельзя копировать, но можно перемещать.

 #+begin_src cpp
void do_some_work();
std::thread my_thread(do_some_work);
 #+end_src

После запуска потока, нужно принять однозначное решение, ждать ли его завершения (=join=) или пустить его в фоне (=detach=).
Дождаться завершения потока можно, вызвав =join()= для связанного экземпляра =std::thread=. Вызов =join()= приводит к очистке объекта =std::thread=, поэтому объект =std::thread= больше не связан с завершенным потоком.
Вызов метода =detach()= для объекта =std::thread= позволяет потоку выполняться в фоновом режиме, непосредственное взаимодействие с ним не требуется. Возможность дождаться завершения этого потока исчезает: если поток отсоединяется, получить ссылающийся на него объект =std::thread= невозможно, поэтому такой поток больше нельзя присоединить.

В С++20 появился новый класс для создания потоков и управления ими =std::jthread=.
Он имеет то же поведение, что и =std::thread=, за исключением того, что =jthread= автоматически join'ится при уничтожении и предлагает интерфейс для остановки потока.
В отличие от =std::thread=, =jthread= содержит внутренний закрытый член типа =std::stop_source=, который хранит =stop-state=. Конструктор =jthread= принимает функцию, которая принимает =std::stop_token= в качестве своего первого аргумента. Этот аргумент передаётся в функцию из =stop_source=, и позволяет функции проверить, была ли запрошена остановка во время ее выполнения, и завершиться при необходимости.

** threads managing
Стандартная библиотека предоставляет несколько методов для управления текущим потоком. Все они находятся в пространстве имён =std::this_thread=:
+ =std::this_thread::yield()= подсказывает планировщику потоков перепланировать выполнение, приостановив текущий поток и отдав преимущество другим потокам. Точное поведение этой функции зависит от реализации, в частности от механики используемого планировщика ОС и состояния системы.
+ =std::this_thread::get_id()= возвращает id потока..
+ =std::this_thread::sleep_for(sleep_duration)= блокирует выполнение текущего потока на время =sleep_duration=.
+ =std::this_thread::sleep_until(sleep_time)= блокирует выполнение текущего потока до наступления момента времени =sleep_time=.

* Атомарные операции
** std::atomic
** atomic operations

* Синхронизация выполнения
** mutual exclusion
** condition variables
** semaphores
** futures
** каналы
* Частые ошибки
* Векторизация
