#+title: grpc

=gRPC= — это современный фреймворк для удаленного вызова процедур (RPC), разработанный Google.
Он основан на протоколе HTTP/2 и использует формат сериализации Protocol Buffers (protobuf), что делает его эффективным и быстрым. gRPC отлично подходит для построения микросервисной архитектуры, позволяя сервисам взаимодействовать друг с другом через строго типизированные API.

=gRPC= решает задачу эффективного взаимодействия между сервисами.
В отличие от REST API, который использует текстовый формат JSON и HTTP/1.1, gRPC работает поверх HTTP/2 и использует бинарный формат Protocol Buffers. Это дает несколько преимуществ:
- Высокая производительность — бинарная сериализация быстрее и компактнее JSON.
- Поддержка потоковой передачи данных — gRPC позволяет реализовывать стриминговые вызовы.
- Языковая независимость — клиенты и серверы могут быть написаны на разных языках.
- Автоматическая генерация кода — API описываются в файлах .proto, а на их основе создаются серверные и клиентские обертки.

Если вам важна производительность, строгая типизация и поддержка потоков — gRPC будет лучшим выбором. Если же нужно простое взаимодействие между сервисами без сложной настройки, REST может быть более удобным.

* Установка gRPC в Go
Перед началом работы необходимо установить пакет gRPC и компилятор Protocol Buffers:
#+begin_src
go install google.golang.org/protobuf/cmd/protoc@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
#+end_src

Эти инструменты нужны для генерации Go-кода из .proto файлов. Теперь добавим зависимости в проект:
#+begin_src
go get google.golang.org/grpc
go get google.golang.org/protobuf
#+end_src

* Определение gRPC-сервиса
В gRPC API описывается с помощью файла .proto. Давайте создадим сервис для управления пользователями:
#+begin_src go
syntax = "proto3";

package main;

option go_package = "./pb";

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
#+end_src

Теперь сгенерируем код для Go:
#+begin_src
protoc --go_out=. --go-grpc_out=. hello.proto
#+end_src

* Реализация сервера
#+begin_src go
package main

import (
	"context"
	"log"
	"net"

	"google.golang.org/grpc"
	pb "grpcex/pb" // Импортируем сгенерированный код
)

type server struct {
	pb.UnimplementedGreeterServer
}

func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
	return &pb.HelloReply{Message: "Hello " + in.Name}, nil
}

func main() {
	lis, err := net.Listen("tcp", ":50051")
	if err != nil {
		log.Fatalf("Failed to listen: %v", err)
	}

	s := grpc.NewServer()
	pb.RegisterGreeterServer(s, &server{})

	log.Println("Server listening on :50051")
	if err := s.Serve(lis); err != nil {
		log.Fatalf("Failed to serve: %v", err)
	}
}
#+end_src

* Реализация клиента
#+begin_src go
package main

import (
	"context"
	"log"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure" // Используем insecure для упрощения
	pb "grpcex/pb" // Импортируем сгенерированный код
)

func main() {
	conn, err := grpc.Dial("localhost:50051", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("Failed to connect: %v", err)
	}
	defer conn.Close()

	client := pb.NewGreeterClient(conn)

	resp, err := client.SayHello(context.Background(), &pb.HelloRequest{Name: "World"})
	if err != nil {
		log.Fatalf("Failed to call SayHello: %v", err)
	}

	log.Printf("Response: %s", resp.Message)
}
#+end_src
