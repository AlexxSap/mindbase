=Микросервисная архитектура= — это подход к проектированию систем, в котором за каждую часть бизнес логики отвечает отдельный модуль.
Каждый микросервис обычно выполняет одну конкретную функцию и взаимодействует с другими модулями через API.
Такой подход — противоположность монолитной архитектуры.
=Монолит= — это когда все сервисы объединены в одну кодовую базу.

Хороший микросервис должен
- быть =небольшим=,
- быть =автономным=,
- обходиться собственной =изолированной базой данных=
- =«закрывать» конкретную потребность=.

* Преимущества
- Быстрый запуск. Микросервис можно запустить гораздо быстрее, чем монолит.
- Масштабируемость.  Можно масштабировать сервисы независимо.
- Упрощение кодовой базы. Для поддержки микросервиса программистам не нужно знать весь код всего продукта
- Независимое развертывание. Разработчики могут частично обновлять сервер, делать канареечные релизы (осторожно внедрять новую версию приложения в продакшн) и проверять нововведения без резких переходов к новой версии (сине-зелёное развертывание). Всё это упрощает процесс разработки.
- Гибкость. При создании микросервисов для проекта вы можете использовать столько языков программирования, фреймворков и инструментов, сколько захотите.

* Недостатки
При кажущейся простоте и логичности деления большого продукта на самостоятельные сервисы разработка распределённой системы — процесс сложный и с технической, и с организационной точек зрения.

Плюсы могут обернуться минусами:
- Сбой одного сервиса не приведёт к полному отказу приложения, но любая распределённая система имеет и другие слабые места: потенциальные проблемы связи её элементов друг с другом, сетевые задержки, возможная неконсистентность данных.
- Вы сэкономите, если будете платить только за те ресурсы, которые потребляют микросервисы, но должны будете предусмотреть расходы на внедрение облачных технологий, отдельное развёртывание каждого нового сервиса и его покрытие отдельными тестами и мониторингами.
- Контролировать качество решения отдельных бизнес-задач проще и эффективнее, чем оценивать систему в целом, но настроить рабочие процессы большой команды разработчиков не так уж легко.

* Кому подойдёт использование микросервисной архитектуры
Если вам или вашему проекту подходит хотя бы один пункт из этого списка, задумайтесь об использовании микросервисов:
- Большие коллективы.
  Группам разработчиков, которые работают над разными микросервисами не нужно синхронизировать друг с другом каждый шаг, выбор инструментов и другие детали. Новые фичи можно разрабатывать параллельно и запускать по мере готовности.
- Объёмные проекты со сложной архитектурой.
  Обновлять и поддерживать отдельные модули намного проще, чем контролировать, как изменения скажутся на системе в целом.
- Продукты с резко меняющимся трафиком.
  Если вашим продуктом начинают чаще пользоваться в период праздников или распродаж, микросервисы позволят вам быстро масштабироваться и уменьшить риск отказа системы. К тому же вам не придётся платить за дополнительную инфраструктуру, которая нужна только в периоды пиковых нагрузок.
- Приложения, требующие частых обновлений.
  Достаточно изменить и отладить только тот модуль, который вы хотите обновить. Это существенно сокращает время разработки и приближает релиз.

* Принципы проектирования сервисов на микросервисной архитектуре
Есть 6 проверенных временем принципов, которые необходимы для владельцев сервисов при определении и согласовании критериев качества, других системных аналитиков, технологов при разработке, модификации сервисов.

- _Знай своего клиента_.
  Каждый сервис должен знать поставщиков (сервис До) и потребителей (сервис После или Клиент). Изменения сервиса должны согласовываться с внутренним потребителем, поставщиком.
- _Следи за своим здоровьем_.
  Он означает что владельцу сервиса необходимо контролировать заявленные критерии качества, выявлять отклонения и их причины. В компании должны быть выстроены единые стандарты по метрикам качества, предъявляемым к мониторингу микросервисов.
- _SMART цифровизации_.
  Владелец сервиса должен стремиться к его в продвижению во всех возможных каналах взаимодействия с клиентом.
- _Максимизации сквозной обработки_.
  Сервис на микросервисной архитектуре не создает дублирующие документы и атрибуты, исключает повторный ввод данных, «предзаполняет» данные для процесса автоматически из мастера источников.
- _Secure-by-Design_.
  Владелец сервиса стремится обеспечить безопасность на всех этапах производственного процесса — от идеи до вывода сервиса из эксплуатации.
- _Эволюционируй вместе с искусственным интеллектом_.
  Владелец сервиса на микросервисной архитектуре стремится использовать возможности AI для создания интеллектуальных сервисов.

* Лайфхак для облечения работы с микросервисами
Одна из сложностей при огромном количестве микросервисов — это необходимость их упорядочивания и систематизации.
В противном случае, можно просто утонуть в различных несвязанных наименованиях API микросервисов, тратя буквально вечность на поиски ответов в тонне документации, что есть что и как их связать.
Важным моментом, существенно облегчающим в будущем отражение связей в документации, является правильное наименование API сервисов, которое существенно упростит жизнь и поддержку версионирования.
#+ATTR_ORG: :width 800
[[file:../att/microname.png]]

* 9 Лучших Практик Разработки Микросервисов
При разработке микросервисов рекомендуется придерживаться следующих практик:
1. Используйте отдельное хранилище данных для каждого микросервиса
2. Поддерживайте одинаковый уровень зрелости кода
3. Выполняйте отдельную сборку для каждого микросервиса
4. Назначайте каждому микросервису одну ответственность
5. Разворачивайте микросервисы в контейнерах
6. Проектируйте сервисы без сохранения состояния (stateless)
7. Используйте предметно-ориентированное проектирование (DDD)
8. Проектируйте микрофронтенды
9. Организуйте оркестрацию микросервисов

* Подходы к построению микросервисной архитектуры

1. =Service Registry= (Реестр сервисов)
Этот паттерн решает проблему обнаружения сервисов в распределенной системе.
Каждый микросервис регистрирует себя в центральном реестре. Когда одному сервису нужно взаимодействовать с другим, он обращается к реестру, чтобы узнать текущий адрес нужного сервиса. Это позволяет сервисам динамически обнаруживать друг друга без жесткой привязки к конкретным адресам.

2. =API Gateway= (API-шлюз)
API Gateway действует как единая точка входа для всех клиентских запросов. Он принимает запросы от клиентов и перенаправляет их соответствующим микросервисам. API Gateway может также выполнять такие задачи, как аутентификация, авторизация и балансировка нагрузки. Это упрощает взаимодействие клиентов с системой, скрывая сложность внутренней архитектуры.

3. =Circuit Breaker= (Предохранитель)
Этот паттерн предотвращает каскадные сбои в системе.
Когда один сервис начинает давать сбои, Circuit Breaker временно блокирует запросы к этому сервису, предотвращая перегрузку и позволяя системе восстановиться. Это повышает устойчивость системы и помогает избежать полного отказа всей системы из-за проблем с одним сервисом.

4. =Bulkhead= (Отсек)
Паттерн Bulkhead изолирует компоненты системы друг от друга, чтобы сбой в одной части не повлиял на другие. Например, для разных сервисов могут использоваться отдельные пулы потоков или базы данных. Это повышает устойчивость системы и ограничивает распространение сбоев.

5. =Saga Pattern= (Сага)
Saga используется для управления распределенными транзакциями в микросервисной архитектуре.
Длительная бизнес-операция разбивается на серию меньших, локальных транзакций. Каждый сервис выполняет свою часть транзакции и публикует событие, которое запускает следующий шаг. Если что-то идет не так, выполняются компенсирующие действия для отмены изменений.

6. =Event Sourcing= (Источник событий)
Вместо хранения только текущего состояния, этот паттерн сохраняет все события, которые привели к этому состоянию. Это обеспечивает надежный аудиторский след и позволяет восстановить состояние системы на любой момент времени. Особенно полезен в системах, где важна история изменений и возможность отката.

7. =Command Query Responsibility Segregation= (=CQRS=, Разделение команд и запросов)
CQRS разделяет операции чтения и записи в приложении. Используются разные модели для обновления информации (команды) и чтения информации (запросы). Это позволяет оптимизировать каждую сторону независимо, что может значительно улучшить производительность и масштабируемость.

8. =Data Sharding= (Шардинг данных)
Этот паттерн используется для распределения нагрузки на базу данных.
Данные разделяются на несколько баз данных или экземпляров базы данных. Каждый микросервис может обрабатывать подмножество данных или определенные типы запросов. Это помогает избежать узких мест в работе с данными и улучшает масштабируемость.

9. =Polyglot Persistence= (Многовариантное хранение)
Этот подход позволяет использовать разные технологии баз данных для разных микросервисов, исходя из их конкретных потребностей. Например, один сервис может использовать реляционную БД, другой – NoSQL, третий – графовую БД. Это оптимизирует хранение, извлечение и обработку данных для каждого сервиса.

10. =Retry= (Повторная попытка)
Обеспечивает повторение операции при возникновении временного сбоя – вместо немедленного отказа. Может применяться на разных уровнях: от взаимодействия между сервисами до работы с базой данных. Помогает справиться с кратковременными проблемами в сети или сервисах.

11. =Sidecar= (Вспомогательный сервис, посредник)
Этот паттерн предполагает присоединение вспомогательного сервиса (sidecar) к основному микросервису для обеспечения дополнительной функциональности, такой как логирование, безопасность или коммуникация с внешними сервисами. Позволяет основному сервису сосредоточиться на своей основной функции.

12. =Backends for Frontends= (BFF, Бэкенды для фронтендов)
BFF предполагает создание отдельных бэкенд-сервисов для каждого типа клиента (веб, мобильный и т. д.). Это позволяет оптимизировать API под конкретные нужды каждого клиента, улучшая производительность и упрощая разработку клиентской части.

13. =Shadow Deployment= (Теневое развертывание)
Этот паттерн предполагает отправку копии (тени) производственного трафика к новой версии микросервиса без влияния на реальный пользовательский опыт. Это позволяет проверить производительность и корректность новой версии в реальных условиях, не подвергая риску текущих пользователей.

14. =Consumer-Driven Contracts= (Контракты, определяемые потребителем)
В этом подходе потребители сервисов определяют свои ожидания от поставщиков сервисов. Это помогает обеспечить более надежные и согласованные изменения в системе. Каждый сервис-потребитель описывает, какой именно функционал и в каком формате он ожидает от сервиса-поставщика.

15. =Smart Endpoints, Dumb Pipes= (Умные конечные точки, глупые каналы)
Этот паттерн рекомендует размещать бизнес-логику в самих микросервисах (умные конечные точки), а не полагаться на сложное промежуточное ПО. Инфраструктура коммуникаций (каналы) должна быть простой и заниматься только маршрутизацией сообщений. Это упрощает систему и делает ее более гибкой.

16. =Database per Service= (База данных для каждого сервиса)
В этом паттерне каждый микросервис имеет собственную базу данных, и сервисы общаются через четко определенные API. Это обеспечивает изоляцию данных и независимость сервисов, но требует тщательного подхода к обеспечению согласованности данных между сервисами.

17. =Async Messaging= (Асинхронный обмен сообщениями)
Вместо синхронного взаимодействия между микросервисами, этот паттерн предполагает использование очередей сообщений для асинхронной коммуникации. Это может улучшить отзывчивость системы и ее масштабируемость, так как сервисы не блокируются в ожидании ответа друг от друга.

18. =Stateless Services= (Сервисы без состояния)
Проектирование микросервисов как stateless (без сохранения состояния) упрощает масштабирование и повышает устойчивость. Каждый сервис обрабатывает запрос независимо, не полагаясь на сохраненное состояние – это облегчает горизонтальное масштабирование.
