#+title: Типовое Использование Rabbit Mq

* Пайплайн
Пайплайн — базовый элемент архитектуры, когда нужна последовательная обработка различными сервисами. Например, сначала требуется проверить авторизацию, затем выполнить дедупликацию и только после произвести запись данных сообщения в базу данных.
За счёт использования очередей в пайплайне хорошо видны bottleneck’и — узкие места, перед которыми скапливаются сообщения на обработку. Также есть понятный механизм расшивания посредством увеличения количества консьюмеров (конечно, это не серебряная пуля, так как проблемы могут быть у другого сервиса типа БД).
Плюс такого подхода — возможность удобного траблшутинга. На любом этапе вы можете добавить дублирующую очередь и получать копии сообщений как для разбора, так и для отправки на непродовые окружения.
Типовой пример пайплайна обработки: Publisher отправляет сообщение, и затем оно передаётся от worker к worker по мере обработки. Worker 1 проверяет авторизацию, 2 — дедупликатор, 3 — пишет в БД.

Представим, что код проверки написан не оптимально, и скорость проверки ниже, чем частота прихода новых сообщений.
#+ATTR_ORG: :width 500 :align left
[[file:../att/queue2.png]]

В этом случае очередь сообщений перед worker 2 начнёт расти, о чём нам тут же сообщит система мониторинга.
Если есть возможность горизонтального масштабирования — запускаем ещё один инстанс worker 2.
И они вдвоём ускоряют обработку сообщений. Разумеется, ускорить обработку таким способом получится не всегда. Если worker’ы упираются в скорость используемой БД, надо расшивать её или оптимизировать их код. Однако узкое горлышко обработки вы будете видеть сразу.

* Очередь повторных попыток
Очередь повторных попыток — один из базовых элементов архитектуры приложения.  Используется, когда есть вероятность неуспешной обработки сообщения (как «временные трудности» в целом, так и проблемы с обработкой конкретного сообщения). Работает, если нет необходимости в строгой последовательности обработки, так как подразумевает возможность временного пропуска сообщения.

Существуют два основных алгоритма реализации:
 - ack+publish — когда consumer сам подтверждает сообщение из основной очереди и паблишит в очередь повторных попыток;
 - reject+dlx — через механизм dead letter exchange.

=Dead Letter eXchange=
Dead Letter eXchange (DLX) — это явное или назначенное через Policy свойство очереди. Указывает RabbitMQ, куда необходимо отправлять сообщение при наступлении одного из событий:
 - x-mesage-ttl — превышение времени жизни;
 - x-max-length — превышение длины очереди;
 - reject — явный реджект сообщений со стороны консьюмера.

Для одной очереди можно указать только один DLX, что несколько снижает гибкость. Также вы можете указать dead-letter-routing-key, а можете не указывать — тогда сохраняется текущий для каждого сообщения.

* Пример ack+publish
Предположим, у нас есть обработка сообщений, использующая некий внешний сервис, находящийся вне нашей зоны ответственности. Пускай сообщение «2» в данный момент не может быть им успешно обработано.
#+ATTR_ORG: :width 700 :align left
[[file:../att/queue3.png]]

Сообщения помещаются в очередь.
Worker берёт сообщение 1 в обработку. После успешной обработки первого сообщения доходит дело до второго — проблемного. Происходит ошибка его обработки.
Если мы сделаем nack этому сообщению, оно вернётся в очередь на тоже самое место. И незамедлительно будет закинуто в worker и будет ходить туда-сюда.
#+ATTR_ORG: :width 700 :align left
[[file:../att/queue4.png]]

Как раз для таких случаев нужен паттерн очереди повторных попыток. Суть в том что мы создаем дополнительную очередь «retry queue», куда складируем неуспешно обработанные сообщения.
В случае ошибки обработки worker должен сделать ACK из основной очереди и publish в новую очередь.
#+ATTR_ORG: :width 700 :align left
[[file:../att/queue5.png]]

В результате для нашего примера 1 и 3 сообщения будут успешно обработаны, а 2 останется в выделенной очереди ожидать своего часа.
Это как раз подход ack+publish. Он наиболее часто используется в IT-системах, потому что разработчики не знают о некоторых возможностях RabitMQ. Но рекомендуется использовать другой метод — reject+DLX.

* Пример reject+dlx
Всё аналогично, но для очереди мы декларируем DLX = Fail, который ведёт в ту самую очередь повторных попыток.
При неуспешной обработке мы делаем reject(false) вместо ack и publish.
Принцип тот же, но работает проще: меньше кода — меньше возможных проблем. Результат ожидаемо аналогичный.
Но ведь нам нужно совершать повторные попытки обработки, а не просто складывать сообщения в отстойник. Для этого мы используем тот же самый механизм DLX + механизм TTL:
#+ATTR_ORG: :width 700 :align left
[[file:../att/queue6.png]]

В результате сообщение 2 будет каждую минуту возвращаться в основную очередь. Будет происходить попытка его обработки и так до тех пор, пока сообщение не будет успешно обработано. Просто и без лишнего кода.
Для очередей без consumer, где возможно хранение сообщений, рекомендую также добавлять признак lazy-queue, чтобы RabbitMQ старался не держать эти сообщения в оперативке.
