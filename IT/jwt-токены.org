#+title: Jwt Токены

JWT — это JSON Web Tokens, простой и безопасный способ передачи информации между клиентом и сервером.

* Формат JWT
JWT (JSON Web Token) состоит из трёх основных частей: =заголовка= (=header=), =полезной нагрузки= (=payload=) и =подписи= (=signature=).
Заголовок и полезная нагрузка формируются в формате JSON, кодируются в Base64, после чего на их основе вычисляется подпись.
Закодированные части соединяются в одну строку, и эта строка становится токеном, который используется для аутентификации и передачи данных.

* Header
Заголовок является служебной частью и содержит информацию о типе токена (в данном случае JWT) и о применённом алгоритме подписи. Например:
#+begin_src json
{
  "typ": "JWT",
  "alg": "HS256"
}
#+end_src
Поле =typ= обозначает тип токена. Хотя некоторые приложения могут игнорировать это поле, стандарт рекомендует его включать для обеспечения совместимости.
Поле =alg= обязательно и указывает на алгоритм, используемый для подписи токена. В данном примере применяется алгоритм HMAC-SHA256 (HS256), который использует единый секретный ключ для подписи и проверки.

JWT также может использовать асимметричные алгоритмы подписи, например, RSA-SHA256 (RS256), где для подписи и проверки используются разные ключи. Стандарт поддерживает множество алгоритмов, таких как HS512, RS512, ES256, ES512, и даже алгоритм none, который указывает на отсутствие подписи. Если используется none, токен не подписан, и его подлинность не может быть проверена.

Закодируем этот JSON в base64 и получим: =eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9=

* Payload
Полезная нагрузка — это данные, которые передаются в JWT. Стандарт предусматривает несколько зарезервированных полей, которые называют “claims”:
- iss — (issuer) издатель токена.
- sub — (subject) назначение токена.
- aud — (audience) аудитория, для которой предназначен токен.
- exp — (expire time) срок действия токена.
- nbf — (not before) время, до которого токен недействителен.
- iat — (issued at) время создания токена.
- jti — (JWT id) уникальный идентификатор токена.

Эти поля не являются обязательными, но важно использовать их правильно, чтобы избежать коллизий и ошибок в обработке.
Кроме зарезервированных полей, можно передавать любые данные по договорённости между сторонами.
Поскольку содержимое =payload= не шифруется, не рекомендуется передавать в нём чувствительные данные, такие как паспортные данные или пароли.
Размер =payload= не ограничен, но его увеличение может негативно сказаться на производительности.

Закодируем этот payload в Base64 и получим вторую часть токена:
=eyJpc3MiOiJBdXRoIFNlcnZlciIsInN1YiI6ImF1dGgiLCJleHAiOjE1MDU0Njc3NTY4NjksImlhdCI6MTUwNTQ2NzE1MjA2OSwidXNlciI6MX0=.

Теперь у нас есть две из трёх частей токена — заголовок и полезная нагрузка. Осталось сгенерировать подпись.

* Signature
Подпись генерируется следующим образом: закодированные в Base64 заголовок и полезная нагрузка объединяются через точку (.).
Получившаяся строка хешируется с использованием алгоритма, указанного в заголовке (header). Результат этого хеширования и есть подпись.

Пример JWT-токена с тремя частями (заголовок, полезная нагрузка и подпись): eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJBdXRoIFNlcnZlciIsInN1YiI6ImF1dGgiLCJleHAiOjE1MDU0Njc3NTY4NjksImlhdCI6MTUwNTQ2NzE1MjA2OSwidXNlciI6MX0.9VPGwNXYfXnNFWH3VsKwhFJ0MazwmNvjSSRZ1vf3ZUU

Другие микросервисы могут проверять JWT-токен двумя способами:
- Симметричный алгоритм (например, HS256): Все сервисы знают единый секретный ключ, который используется для подписи токенов.
- Асимметричный алгоритм (например, RS256): В этом случае сервер авторизации использует приватный ключ для подписания токенов, а другие сервисы могут проверять подпись, используя соответствующий публичный ключ. Такой подход более безопасен, так как приватный ключ остаётся только у сервера авторизации.
- =Пример атаки=: если злоумышленник попытается изменить данные в токене (например, роль пользователя на “admin”), он не сможет создать новую валидную подпись для этого токена, что делает подобные изменения бессмысленными.

Официальный сайт jwt.io предлагает два популярных алгоритма хэширования: HS256 (симметричный) и RS256 (асимметричный), но можно использовать и другие алгоритмы с приватным ключом, например ES256 или HS512.

* Аутентификация
Схема аутентификации с использованием JWT проста и эффективна. Процесс выглядит следующим образом:
- Пользователь вводит свои учётные данные в приложении или на доверенном сервисе аутентификации.
- При успешной аутентификации сервис генерирует JWT-токен, который содержит сведения о пользователе.
- Этот токен передаётся пользователю и сохраняется в браузере или приложении. При последующих запросах токен отправляется вместе с запросом на сервер: в cookie, заголовках HTTP-запроса, либо в параметрах POST или GET.

Передача токенов через GET-параметры нежелательна из-за риска утечек данных в логи или истории браузера. Предпочтительным способом передачи токена является использование заголовков или cookie с пометкой HttpOnly и Secure, чтобы минимизировать риски кражи токенов.

Получив JWT, приложение выполняет следующие шаги:
- Проверка подписи: Приложение проверяет подпись токена, чтобы убедиться, что токен не был подделан.
- Извлечение данных: После подтверждения подлинности токена приложение извлекает информацию о пользователе из полезной нагрузки (payload) токена.
- Авторизация: На основе этих данных приложение предоставляет пользователю доступ к нужным ресурсам.

* Преимущества JWT
Использование JWT имеет ряд преимуществ по сравнению с классической схемой аутентификации на основе сессий:
- Отсутствие необходимости хранения сессий на сервере.
  В отличие от классической схемы, где сервер должен хранить информацию обо всех активных сессиях, JWT позволяет обойтись без этого. Когда пользователь отправляет запрос с токеном, приложению достаточно проверить его подпись и извлечь данные из полезной нагрузки. Это упрощает масштабирование приложения, так как серверу не нужно управлять сессиями.

- Делегирование выдачи и валидации токенов.
  Приложение не обязано самостоятельно заниматься генерацией и проверкой токенов — эту задачу можно передать отдельному сервису аутентификации. Это позволяет упростить архитектуру приложения и повысить безопасность, так как управление токенами централизовано.

- Поддержка единого входа (SSO).
  Используя отдельный сервис аутентификации, можно организовать единую точку входа (Single Sign-On, SSO) для нескольких приложений или сервисов. После прохождения аутентификации пользователь получает токен, который может быть использован для доступа ко всем доверенным сервисам без повторного ввода учётных данных.

- Гибкость полезной нагрузки.
  В полезную нагрузку JWT можно включать любые данные о пользователе, что позволяет приложению работать более эффективно. Например, в токен можно включить информацию о ролях пользователя или других атрибутах, чтобы не обращаться к базе данных для их получения при каждом запросе. Это может значительно повысить производительность при грамотной архитектуре.

Благодаря этим преимуществам JWT широко используется в корпоративных приложениях, особенно в микросервисной архитектуре. В таких системах каждый микросервис может извлекать необходимые сведения о пользователе напрямую из токена, не выполняя дополнительных запросов к базе данных или другим сервисам.

* Уязвимости JWT
** Перехват токена
Если JWT хранится в открытом виде (например, в localStorage), любой вредоносный скрипт может получить к нему доступ. В результате, даже если токен имеет короткий срок действия, он может быть использован злоумышленником до его истечения для выполнения вредоносных действий.

Перехват JWT может привести к серьёзным последствиям. Рассмотрим основные риски:
  - Извлечение данных из токена.
    JWT передаётся в открытом виде, а его полезная нагрузка (payload) кодируется с помощью Base64Url. Это не является шифрованием, и любой злоумышленник, перехвативший токен, может декодировать payload и получить доступ к содержащимся в нём данным, применив функцию base64UrlDecode. В случае утечки токена злоумышленник сможет извлечь информацию о пользователе, такую как идентификатор или другие персональные данные.
  - Повторное использование токена.
    Если злоумышленник перехватит токен, он сможет использовать его для получения доступа к защищённым ресурсам от имени пользователя. Это возможно потому, что JWT остаётся действительным до истечения срока его действия.

=Рекомендации по предотвращению=
- Используйте HTTPS для всех запросов, передающих JWT, чтобы предотвратить перехват токена.
- Использование HttpOnly cookie. Вместо хранения JWT в localStorage или sessionStorage, лучше использовать HttpOnly cookies. Эти cookie недоступны для JavaScript, что значительно снижает риск кражи токена через XSS-атаки
- Не храните в JWT чувствительные данные. В полезной нагрузке стоит передавать только минимально необходимые данные, такие как обезличенные идентификаторы пользователей или данные, которые не представляют угрозу в случае утечки.
- Ограничьте срок действия JWT. Это минимизирует время, в течение которого перехваченный токен остаётся активным. Обычно рекомендуется устанавливать срок действия токена на несколько минут.
- Используйте механизм обновления токенов (=refresh tokens=). В случае короткого срока действия JWT можно использовать refresh-токен для безопасного получения нового JWT без необходимости повторной аутентификации. Refresh-токены также должны быть передаваемы только по защищённому соединению и иметь более строгие механизмы контроля.

** Refresh tokens
В современных схемах аутентификации с использованием JWT, после успешной аутентификации пользователь получает два токена:
- =Access token= — JWT, который используется для идентификации и авторизации пользователя при запросах к приложению.
- =Refresh token= — токен произвольного формата, предназначенный для безопасного обновления access token, когда срок его действия истекает.

=Access token= имеет ограниченное время жизни (например, одну минуту), что минимизирует риски при его компрометации. =Refresh token=, напротив, действует дольше (например, день, неделю или месяц), но он одноразовый — его можно использовать только для получения нового =access token=.

Схема аутентификации в таком случае выглядит следующим образом:
- Пользователь проходит аутентификацию и получает от сервера два токена: =access token= и =refresh token=.
- При каждом запросе к защищённому ресурсу пользователь отправляет =access token=, и сервер на его основе идентифицирует и авторизует пользователя.
- Когда срок действия =access token= истекает, клиент отправляет =refresh token=, чтобы получить новый =access token= и, как правило, новый =refresh token=.
- Когда срок действия =refresh token= истекает, пользователь должен пройти аутентификацию снова.

Рекомендации по безопасности при работе с =refresh tokens=:
- Храните =refresh token= в защищённом месте. Например, в HttpOnly и Secure cookie, чтобы предотвратить его кражу через JavaScript (XSS-атаки).
- Реализуйте механизмы отзыва =refresh tokens=. В случае компрометации, сервер должен иметь возможность отозвать =refresh token= и не допустить его использования.
- Ограничьте срок жизни =refresh token= и обеспечьте возможность его однократного использования, чтобы минимизировать риск его повторного применения злоумышленником.

** Подбор ключа симметричного алгоритма подписи
При использовании симметричных алгоритмов для подписи JWT (например, HS256, HS512), существует риск подбора ключевой фразы злоумышленником. Если злоумышленнику удастся подобрать ключ, он сможет манипулировать JWT, как если бы он был частью системы. Это позволит ему генерировать поддельные токены, выдавая себя за любого пользователя, и получать доступ к защищённым ресурсам.

Например, если для подписи JWT используется слабая ключевая фраза, как в случае строки "password", злоумышленник легко подберёт её, используя программы для взлома, такие как John the Ripper или hashcat. Простые ключи, такие как "password", содержатся в большинстве словарей для перебора паролей и являются первыми кандидатами для атаки.

Рекомендации по защите от подбора ключа:
- Используйте надёжные ключевые фразы: Ключевая фраза для подписи JWT должна быть длинной и сложной. Рекомендуется использовать комбинации заглавных и строчных букв латинского алфавита, цифр и специальных символов. Например, строка длиной 32 символа с хорошим сочетанием символов существенно усложнит задачу для злоумышленников и сделает подбор ключа практически невозможным.
- Храните ключи в строгой конфиденциальности: Никогда не храните ключи в открытом виде в коде или файлах конфигурации, доступных посторонним. Используйте безопасные хранилища секретов и убедитесь, что доступ к ним строго ограничен.
- Регулярно меняйте ключи: Периодическая смена ключевой фразы значительно усложнит жизнь злоумышленнику, даже если ему удастся приблизиться к её подбору. Однако следует учитывать, что смена ключа приведёт к аннулированию всех текущих токенов, и пользователям придётся повторно проходить аутентификацию. Этот компромисс между безопасностью и удобством стоит учитывать при настройке частоты смены ключа.

** Использование алгоритма none
Как упоминалось ранее, если в заголовке JWT указан алгоритм none, это означает, что токен не был подписан. В таком случае токен не имеет подписи, что делает невозможным проверку его подлинности. Это может быть использовано злоумышленниками для атак, позволяющих подделать данные в токене.

Как защититься от атаки с использованием none:
- Используйте белый список алгоритмов: На стороне сервера необходимо настроить белый список разрешённых алгоритмов подписи и отклонять все JWT с алгоритмом none. Это гарантирует, что только токены, подписанные разрешёнными алгоритмами, будут приняты.
- Используйте один алгоритм: Для минимизации рисков лучше всего использовать один алгоритм для подписи JWT. Например, HS256 (симметричный алгоритм) или RS256 (асимметричный алгоритм). Это упрощает управление безопасностью и снижает вероятность ошибок.

** Изменение алгоритма подписи
При использовании асимметричных алгоритмов, таких как RS256, подпись токена осуществляется с использованием приватного ключа, а проверка подписи — с использованием публичного ключа.

В некоторых случаях злоумышленники могут воспользоваться уязвимостями, связанными с проверкой JWT. Например, если токен подписан асимметричным алгоритмом (RS256), а сервер допускает использование симметричного алгоритма (HS256), злоумышленник может подделать токен, используя публичный ключ как секретный ключ.

Для предотвращения такой атаки рекомендуется:
- Использовать белый список алгоритмов. Разрешать только конкретные алгоритмы подписи на сервере, например, RS256. Все токены с неподдерживаемыми алгоритмами должны быть отклонены.
- Строго разделять симметричные и асимметричные алгоритмы. Если используется асимметричная схема, как RS256, то симметричные алгоритмы (например, HS256) не должны быть допустимы.
- Проверка библиотеки. Убедитесь, что библиотека для работы с JWT правильно реализует проверку подписей, и не использует публичный ключ как секретную фразу при симметричных алгоритмах.

* Пример генерации токена
#+begin_src go
package main

import (
	"fmt"
	"time"

	jwt "github.com/golang-jwt/jwt/v5"
)

func main() {
	// Создаем claims (утверждения), которые будут включены в токен
	claims := jwt.MapClaims{
		"usr":   "alex",                                 // имя пользователя
		"isAdm": false,                                  // является ли пользователь админом
		"exp":   time.Now().Add(2 * time.Minute).Unix(), // время жизни токена
	}

	// Генерируем подписанный JWT токен с алгоритмом HMAC (HS256)
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	// Задаем секретный ключ для подписи токена
	key := "my_secret_key"

	// Подписываем токен и получаем его строковое представление
	str, err := token.SignedString([]byte(key))
	if err != nil {
		panic(err)
	}
	fmt.Printf("Сгенерированный JWT токен: %s\n", str)
}
#+end_src

* Проверка токена
#+begin_src go

package main

import (
	"fmt"
	"log"
	"time"

	jwt "github.com/golang-jwt/jwt/v5"
)

func main() {
	key := "my_secret_key"
    str := "..." // строка токена
	// Разбираем токен
	readedToker, err := jwt.Parse(str,
		func(token *jwt.Token) (any, error) {
			// Убедитесь, что используется правильный алгоритм подписи
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unknown sign method: %v", token.Header["alg"])
			}
			return []byte(key), nil
		})

	if err != nil {
		panic(err)
	}

	// Проверяем, является ли токен валидным
	if readedClaims, ok := readedToker.Claims.(jwt.MapClaims); ok && readedToker.Valid {
		fmt.Println("Токен валиден!")
		fmt.Printf("Имя пользователя: %v\n", readedClaims["usr"])
		fmt.Printf("Роль администратора: %v\n", readedClaims["isAdm"])
		fmt.Printf("Время истечения: %v\n", time.Unix(int64(readedClaims["exp"].(float64)), 0))
	} else {
		log.Fatalf("Ошибка при проверке токена: %v", err)
	}
}
#+end_src
