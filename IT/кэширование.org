#+title: Кэширование

[[https://www.youtube.com/watch?v=iLMlYgQoTIE][ссылка на видео]]
https://habr.com/ru/articles/734660/

* Зачем кэшировать
+ Сокращение времени отклика
+ Снижение нагрузки на сервисы
+ Переиспользование ранее полученных или вычесленных данных
+ Стабилизация работы при кратковременных сбоях
+ =НО= нужно держать нагрузку без кэша, он для ускорения ответа, а не для возможности работы.

* Термины
+ =cache miss= - промах, нужный ключ не найден
+ =cache hit= - попадание, нужный ключ найден
+ =hit ratio= - процент попаданий
+ =горячий ключ= - ключ на который приходится бОльшая часть запросов
+ =прогрев кэша= - наполнение кэша данными
+ =инвалидация= - удаление неактуальных данных из кэша

* Что нужно кэшировать, а что не нужно
+ Если данные меняются часто, то кэшировать их не нужно
+ если данные меняются редко, то нужно закэшировать
+ можно кэшировать ошибки и кэш-промахи

* Всегда ли кэшировать полезно
Можно вычислить эффективность кэша
#+begin_quote
AverageTime = DBAccessTime * CacheMissRate + CacheAccessTime
#+end_quote

* Виды кэширования по расположению
** Внутреннее
Кэш расположен внутри приложения, как данные в ОП.
"+":
- высокая скорость
- нет сетевых запросов
- нет расходов на маршалинг
"-":
- горизонтальное масштабирование
- прогрев кэша после падения

** Внешнее
Кэш на внешнем сервисе
"+":
- можно хранить большие объёмы
- простое горизонтальное масштабирование
- кэш не теряется после падения
- простой прогрев и простая логика инвалидации
"-":
- скорость работы
* Способы взаимодействия с кэшем
** cache aside
Приложение само координирует запросы в кэш и решает куда и когда обращаться.
*** Чтение
#+ATTR_ORG: :width 600 :align left
[[file:../att/read_aside.png]]

*** Запись
#+ATTR_ORG: :width 600 :align left
[[file:../att/write_aside.png]]

** cache through
Сквозное кэширование - все запросы приложения проходят через кэш
#+ATTR_ORG: :width 800 :align left
[[file:../att/write_through.png]]

#+ATTR_ORG: :width 800 :align left
[[file:../att/read_through.png]]

"+": сервис работает только с кэшем
"-": если кэш упадёт - то приложение не работает

** cache ahead
Опережающее кэширование. Запросы на чтение всегда идут только в кэш, никогда не попадая в БД напрямую.
#+ATTR_ORG: :width 800 :align left
[[file:../att/cache_ahead.png]]

"+": быстрое чтение и запись
"-": если кэш упал, то ничего не работает и часть данных пропала

* Алгоритмы вытеснения данных
+ случайно
+ FIFO - очередь
+ LIFO - стэк
+ LRU - вытесняется тот элемент, к которому дольше всего не было обращений
+ MRU - вытесняется тот элемент, к которому только что обращались
+ LFU - вытесняется тот, к которому реже всего обращаются
+ Алгоритм Белади (оптимальный)
  не принимый на практике, теоретический идеальный алгоритм
  Если бы мы знали, когда будет обращение к каждому элементу, то вытесняли бы самый поздний
+ Second chanse - при обращении выставляется бит присутствия, а при вытеснении удаляется элемент из начала очереди, если этот бит = 0. Если бит = 1, то элемент переносится в конец очереди.
+ Clock - тот же second chanse, только не нужно передвигать элементы. Они расположены по кругу (как в часах) и передвигается курсор (стрелка) от элементу к элементу.
+ 2Q - есть 2 очереди. Элементы из 1-й очереди никуда не двигаются. Элементы из 2 очереди уходят в =LRU=, вытесненные из 2-й очереди удаляются. Из 1-й очереди переходят во вторую.
+ SLRU - segmented lru. Есть 3 разных уровня LRU - hot, warm, cold. При обращении элементы передвигаются между ними.
+ TLRU - на каждый элемент еще вешается TTL
+ LRU-K - LRU учитывается только после k-того обращения к элементу.

* Инвалидация данных
+ по TTL - основная проблема - выбор времени жизни
+ JITTER - если записи становятся недействительными обновременно и большом количестве, то источник данных может пострадать (БД). Jitter - это случайная величина, которая добавляется к ttl.
+ thundering herb problem - резкий рост нагрузки на источник данных, когда много потоков/процессов/сервисов одновременно запрашивают данные и получают cache miss, а затем каждый из них выполняется запрос к БД. Решается блокировками и proxy.
+ Инвалидация по событию

* Версионирование кэша
К ключу добавляется тэг версии. Затем данные инвалидируются для конкретной версии.

* Типичные случаи сбоев в работе кеша и способы их решения
- =Thundering herd problem=: возникает, когда множество ключей в кеше истекают одновременно. Тогда все запросы напрямую обращаются к базе данных, перегружая её. Устанавливать случайный TTL.
- =Cache penetration=: случается, когда ключ отсутствует и в кеше, и в базе данных. Приложение не может найти нужные данные и обновить кеш, что создаёт нагрузку и на кеш, и на БД. Использовать фильтр Блума для проверки ключей.
- =Cache breakdown=: возникает, когда «горячий» ключ (часто запрашиваемые данные) истекает, и множество запросов обращаются к базе данных. Не ставить TTL для горячих ключей.
- =Cache crash=: возникает, когда кеш выходит из строя, и все запросы направляются напрямую в базу данных. Использовать кэш-кластер.
