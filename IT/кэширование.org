#+title: Кэширование

[[https://www.youtube.com/watch?v=iLMlYgQoTIE][ссылка на видео]]

* Зачем кэшировать
+ Сокращение времени отклика
+ Снижение нагрузки на сервисы
+ Переиспользование ранее полученных или вычесленных данных
+ Стабилизация работы при кратковременных сбоях
+ =НО= нужно держать нагрузку без кэша, он для ускорения ответа, а не для возможности работы.

* Термины
+ =cache miss= - промах, нужный ключ не найден
+ =cache hit= - попадание, нужный ключ найден
+ =hit ratio= - процент попаданий
+ =горячий ключ= - ключ на который приходится бОльшая часть запросов
+ =прогрев кэша= - наполнение кэша данными
+ =инвалидация= - удаление неактуальных данных из кэша

* Что нужно кэшировать, а что не нужно
+ Если данные меняются часто, то кэшировать их не нужно
+ если данные меняются редко, то нужно закэшировать
+ можно кэшировать ошибки и кэш-промахи

* Всегда ли кэшировать полезно
Можно вычислить эффективность кэша
#+begin_quote
AverageTime = DBAccessTime * CacheMissRate + CacheAccessTime
#+end_quote

* Виды кэширования по расположению
** Внутреннее
Кэш расположен внутри приложения, как данные в ОП.
"+":
- высокая скорость
- нет сетевых запросов
- нет расходов на маршалинг
"-":
- горизонтальное масштабирование
- прогрев кэша после падения

** Внешнее
Кэш на внешнем сервисе
"+":
- можно хранить большие объёмы
- простое горизонтальное масштабирование
- кэш не теряется после падения
- простой прогрев и простая логика инвалидации
"-":
- скорость работы
* Способы взаимодействия с кэшем
** cache aside
Приложение само координирует запросы в кэш и решает куда и когда обращаться.
*** Чтение
+------+                      +-------+
|      | 1. чтение из кэша    |       |
|  A   | -------------------> |   C   |
|  P   | 2. даные не нашли    |   A   |
|  P   | <------------------- |   C   |
|  L   | 5. обновили кэш      |   H   |
|  I   | -------------------> |   E   |
|  C   |                      +-------+
|  A   |
|  T   |                      +-------+
|  I   | 3. читаем из БД      |       |
|  O   | -------------------> |   D   |
|  N   | 4. получаем данные   |   B   |
|      | <------------------- |       |
+------+                      +-------+

*** Запись
+------+                      +-------+
|  A   | 3. Обн. кэша         | CACHE |
|  P   | -------------------> |       |
|  P   |                      +-------+
|  L   |
|      | 1. Сохраняем в базу  +-------+
|      | -------------------> |       |
|      | 2. Получаем ответ    |  DB   |
|      | <------------------- |       |
+------+                      +-------+

** cache through
Сквозное кэширование - все запосы приложения проходят через кэш

+-----+                    +-----+                            +-----+
|  A  | 1.читаем из кэша   |  C  | 2. если нет, читаем из БД  |     |
|  P  | -----------------> |  A  | -------------------------> |  B  |
|  P  |                    |  C  |                            |  D  |
|  L  | 4. отдаём данные   |  H  | 3. сохраняем данные в кэш  |     |
|     | <----------------- |  E  | <------------------------- |     |
+-----+                    +-----+                            +-----+

"+": сервис работает только с кэшем
"-": если кэш упадёт - то приложение не работает
** cache ahead
Опережающее кэширование. Запросы на чтение всегда идут только в кэш, никогда не попадая в БД напрямую.

+-----+                    +-----+                            +-----+
|  A  | читаем из кэша     |  C  | периодически записываем    |     |
|  P  | -----------------> |  A  | -------------------------> |  B  |
|  P  |                    |  C  |                            |  D  |
|  L  |  отдаём данные     |  H  |                            |     |
|     | <----------------- |  E  |                            |     |
+-----+                    +-----+                            +-----+

"+": быстрое чтение и запись
"-": если кэш упал, то ничего не работает и часть данных пропала

* Алгоритмы вытеснения данных
+ случайно
+ FIFO - очередь
+ LIFO - стэк
+ LRU - вытесняется тот элемент, к которому дольше всего не было обращений
+ MRU - вытесняется тот элемент, к которому только что обращались
+ LFU - вытесняется тот, к которому реже всего обращаются
+ Алгоритм Белади (оптимальный)
  не принимый на практике, теоретический идеальный алгоритм
  Если бы мы знали, когда будет обращение к каждому элементу, то вытесняли бы самый поздний
+ Second chanse - при обращении выставляется бит присутствия, а при вытеснении удаляется элемент из начала очереди, если этот бит = 0. Если бит = 1, то элемент переносится в конец очереди.
+ Clock - тот же second chanse, только не нужно передвигать элементы. Они расположены по кругу (как в часах) и передвигается курсор (стрелка) от элементу к элементу.
+ 2Q - есть 2 очереди. Элементы из 1-й очереди никуда не двигаются. Элементы из 2 очереди уходят в =LRU=, вытесненные из 2-й очереди удаляются. Из 1-й очереди переходят во вторую.
+ SLRU - segmented lru. Есть 3 разных уровня LRU - hot, warm, cold. При обращении элементы передвигаются между ними.
+ TLRU - на каждый элемент еще вешается TTL
+ LRU-K - LRU учитывается только после k-того обращения к элементу.

* Инвалидация данных
+ по TTL - основная проблема - выбор времени жизни
+ JITTER - если записи становятся недействительными обновременно и большом количестве, то источник данных может пострадать (БД). Jitter - это случайная величина, которая добавляется к ttl.
+ thundering herb problem - резкий рост нагрузки на источник данных, когда много потоков/процессов/сервисов одновременно запрашивают данные и получают cache miss, а затем каждый из них выполняется запрос к БД. Решается блокировками и proxy.
+ Инвалидация по событию

* Версионирование кэша
К ключу добавляется тэг версии. Затем данные инвалидируются для конкретной версии.

* Типичные случаи сбоев в работе кеша и способы их решения
- =Thundering herd problem=: возникает, когда множество ключей в кеше истекают одновременно. Тогда все запросы напрямую обращаются к базе данных, перегружая её. Устанавливать случайный TTL.
- =Cache penetration=: случается, когда ключ отсутствует и в кеше, и в базе данных. Приложение не может найти нужные данные и обновить кеш, что создаёт нагрузку и на кеш, и на БД. Использовать фильтр Блума для проверки ключей.
- =Cache breakdown=: возникает, когда «горячий» ключ (часто запрашиваемые данные) истекает, и множество запросов обращаются к базе данных. Не ставить TTL для горячих ключей.
- =Cache crash=: возникает, когда кеш выходит из строя, и все запросы направляются напрямую в базу данных. Использовать кэш-кластер.
