#+title: Иерархии Памяти

* Общее
Система памяти образует иерархию устройств хранения с разными ёмкостями, стоимостью и временем доступа.
=Регистры процессора= хранят наиболее часто используемые данные.
=Маленькие быстрые кэш-памяти=, расположенные близко к процессору, служат буферными зонами, которые хранят маленькую часть данных, расположеных в относительно медленной оперативной памяти.
=Оперативная память= служит буфером для медленных локальных дисков.
А =локальные диски= служат буфером для данных с удалённых машин, связанных сетью.

Различные виды памяти образуют =иерархию=, на различных уровнях которой расположены памяти с отличающимися временем доступа, сложностью, стоимостью и объёмом.
Возможность построения иерархии памяти вызвана тем, что большинство алгоритмов обращаются в каждый промежуток времени к небольшому набору данных, который может быть помещен в более быструю, но дорогую и поэтому небольшую, память.

* Иерархии памяти
Часто выделяют 4 основных (укрупнённых) уровня иерархии:
1. =Внутренняя память процессора= (регистры, организованные в регистровый файл и кэш процессора).
2. =ОЗУ системы= (RAM) и вспомогательных карт памяти.
3. =Накопители с «горячим» доступом= (On-line mass storage) — или =вторичная компьютерная память=. Жесткие диски и твердотельные накопители, не требующие длительных (секунды и больше) действий для начала получения данных.
4. Накопители, требующие переключения носителей (Off-line bulk storage) — или =третичная память=. Сюда относятся магнитные ленты, ленточные и дисковые библиотеки, требующие длительной перемотки либо механического (или ручного) переключения носителей информации.

В большинстве современных ПК используется следующая иерархия памяти:
1. =Регистры процессора=, организованные в регистровый файл — наиболее быстрый доступ (порядка 1 такта), но размером лишь в несколько сотен или, редко, тысяч байт.
2. Кэш процессора 1го уровня (=L1=) — время доступа порядка нескольких тактов, размером в десятки килобайт
3. Кэш процессора 2го уровня (=L2=) — большее время доступа (от 2 до 10 раз медленнее L1), около полумегабайта или более
4. Кэш процессора 3го уровня (=L3=) — время доступа около сотни тактов, размером от нескольких мегабайт до сотен
5. Кэш процессора 4го уровня (=L4=) — время доступа несколько сотен тактов, размером одну-несколько сотен мегабайт. Применялся в процессорах Intel 5го поколения
6. =ОЗУ= системы — время доступа от сотен до, возможно, тысячи тактов, но огромные размеры, от нескольких гигабайт до нескольких терабайт. Время доступа к ОЗУ может варьироваться для разных его частей в случае комплексов класса NUMA (с неоднородным доступом в память)
7. =Дисковое хранилище= — многие миллионы тактов, если данные не были закэшированны или забуферизованны заранее, размеры до нескольких терабайт
8. =Третичная память= — задержки до нескольких секунд или минут, но практически неограниченные объёмы (ленточные библиотеки).

* Локальность
Когды мы работаем над данными, желательно чтобы они находились в памяти рядом.
Локальность бывает двух типов:
+ Когда мы обращаемся к одному и тому же месту в памяти много раз, это =временнáя локальность=.
+ Когда мы обращаемся к данным, а потом обращаемся к другим данным, которые расположены в памяти рядом с первоначальными, это =пространственная локальность=.

Рассмотрим, программу, которая суммирует элементы массива:
#+begin_src cpp
int sum(int size, int A[])
{
    int i, sum = 0;

    for (i = 0; i < size; i++)
        sum += A[i];
    return sum;
}
#+end_src
В этой программе обращение к переменным =sum= и =i= происходит на каждой итерации цикла. Они имеют хорошую =временную локальность= и будут расположены в быстрых регистрах процессора.
Элементы массива =A= имеют плохую временную локальность, потому что к каждому элементу мы обращаемся только по разу. Но зато они имеют хорошую =пространственную локальность= — тронув один элемент, мы затем трогаем элементы рядом с ним.
Все данные в этой программе имеют или хорошую временную локальность или хорошую пространственную локальность, поэтому мы говорим что программа в общем имеет хорошую локальность.

Когда процессор читает данные из памяти, он их копирует в свой кэш, удаляя при этом из кэша другие данные. Какие данные он выбирает для удаления тема сложная.
Но результат в том, что если к каким-то данным обращаться часто, они имеют больше шансов оставаться в кэше. В этом выгода от временной локальности. Программе лучше работать с меньшим количеством переменных и обращаться к ним чаще.
Перемещение данных между уровнями иерархии осуществляется блоками определённого размера. Поэтому если вы читаете какие-то байты из памяти, а потом читаете байты рядом с ними, они наверняка будут в кэше. В этом выгода от пространственной локальности. Нужно стремиться на каждом этапе вычисления работать с данными, которые расположены в памяти рядом.
