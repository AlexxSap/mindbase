10 вопросов, которые я задаю себе перед код-ревью

Хорошее ревью – это искусство. Это =баланс= между вниманием к деталям и пониманием общей картины. Это когда ты помогаешь сделать чужую работу лучше, не мешая ее закончить.

1. Понимаю ли я, =что делает этот код= – сразу, без контекста?
   Если я читаю код и не могу понять, что происходит: либо код сложный, либо названия плохие, либо логика зашита в 5 разных слоёв. Я не двигаюсь дальше, пока не понял. Если мне – более менее опытному человеку – непонятно, как это работает, что будет с тем, кто будет это дебажить через полгода?

2. =Где тут может случиться баг?=
   Я смотрю не на happy path, а на всё, что может пойти не так:
   – Что если коллекция пустая?
   – Что если null?
   – Что если придёт плохой json?
   – Что если база вернёт 0 строк?
   – А если api даст 500?

   Одна из самых ценных привычек – думать как "злой пользователь".
   Ты не враг автору кода. Ты его страховой полис.

3. =Что случится, если этот код вызовется 1000 раз в секунду?=
   Производительность важна не тогда, когда сломалось, а до этого.
   Я всегда задаю вопрос:
   – Насколько этот код тяжёлый?
   – Не делает ли он много запросов в базу?
   – Нет ли вложенных filter() или map() в цикле?
   – Нет ли рекурсии без ограничений?

4. =Есть ли тут неожиданные побочные эффекты?=
   Я смотрю, не изменяет ли этот код глобальные состояния:
   – Не пишет ли он в базу там, где ожидается просто чтение?
   – Не мутирует ли DTO?
   – Не вызывает ли сторонние сервисы, где их никто не ждал?

   Хороший код – предсказуем. Плохой – с сюрпризами.

5. =Этот код вообще тестируемый?=
   Я задаю себе вопрос:
   – А могу ли я протестировать эту бизнес-логику без запуска всего Spring Boot
   – Можно ли покрыть это юнит-тестами или только e2e
   – Нет ли зависимости от static/new/System/Clock/UUID.randomUUID()?

   Если код не тестируемый – его нужно дорабатывать.

6. =Этот код действительно нужен?=
   Один из самых полезных вопросов.
   Иногда люди переусложняют, дублируют уже существующее, пишут utility-классы вместо того, чтобы использовать стандартные api.
   Я спрашиваю: а можно ли этого вообще не писать?

   ~Удаление ненужного – высший навык программиста~.

7. =Этот код вписывается в архитектуру и стиль проекта?=
   – Не нарушены ли границы (например, репозиторий, который вызывает RestTemplate или UI вдруг тянет Entity)
   – Названия, формат, структура – соответствуют ли общему стилю?

   Код, выбивающийся из общей картины, становится очагом хаоса.

8. =Что произойдёт, если это выкатится в прод?=
   Я мысленно делаю шаг вперёд:
   – Нет ли потенциальных рисков?
   – Все ли граничные кейсы продуманы?
   – Есть ли логирование, чтобы отследить поведение?
   – Алерты сработают, если что-то пойдёт не так?

   Ревью – это как генеральная репетиция перед боем. Ты должен быть готов, что завтра этот код попадёт в руки настоящих пользователей.

9. =Кто будет это поддерживать через год?=
   Я представляю ситуацию: приходит новый разработчик, открывает этот класс – и ничего не понимает.
   Смотрит на метод processDataAndSaveIfValid(), в котором 80 строк, и там происходит магия.

   Я задаю себе вопрос: а что будет, если на месте этого разработчика окажусь я сам?
   Буду ли я ругать коллег за этот код?
   Если да – я должен это сказать автору PR.

10. =Этот код – повод для гордости или источник стыда?=
    Это финальный субъективный вопрос.
    Если бы этот код написал ты – ты бы хотел, чтобы его показывали на митапе как пример хорошей практики?
    Если да – апрув.
    Если нет – не молчи.

Вместо вывода
Плохое ревью – это «ну вроде норм», «там стиль поправь», «сделай красиво».
Хорошее ревью – это диалог, наставничество, совместное улучшение кода.
Ревью – это не поиск виноватого. Это коллективная инженерная зрелость.

~Чек-лист для Code Review:~

1. Архитектура и дизайн
• Соответствует ли код общей архитектуре проекта?
• Не нарушаются ли SOLID принципы?
• Правильно ли выбраны абстракции и интерфейсы?

2. Логика и корректность
• Корректно ли реализована бизнес-логика?
• Обрабатываются ли все edge cases?
• Нет ли off-by-one ошибок в циклах?

3. Безопасность кода
• Правильно ли управляется память?
• Нет ли потенциальных buffer overflow'ов?
• Корректно ли обрабатываются исключения?

4. Производительность
• Нет ли ненужных копирований объектов?
• Эффективны ли используемые алгоритмы?
• Правильно ли используются контейнеры STL?

5. Читаемость и поддерживаемость
• Понятны ли названия переменных и функций?
• Достаточно ли комментариев для сложной логики?
• Не слишком ли сложные функции (соблюдается ли SRP)?

6. Соответствие стандартам
• Следует ли код style guide проекта?
• Используются ли современные возможности C++?
• Корректно ли оформлены заголовочные файлы?

7. Тестирование
• Покрыт ли новый код unit тестами?
• Обновлены ли существующие тесты?
• Протестированы ли edge cases?

8. Документация
• Обновлена ли документация API?
• Есть ли примеры использования для новых функций?
• Актуальны ли комментарии в коде?

9. Обратная совместимость
• нарушается ли API существующих компонентов?
• Совместимы ли изменения с используемыми версиями библиотек?

10. Финальная проверка
• Проходят ли все автоматические тесты?
• Нет ли compiler warnings?
• Готов ли код к production?
