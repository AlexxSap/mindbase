**Такое разное ветвление**

В языке `haskell` существует несколько способов поменять линейный ход выполнения программы.

**Условный оператор if**
отличается от аналогов в императивных языках тем, что он является выражением, а не управляющей конструкцией. 
Это означает, что:
- `if` всегда должен иметь и `then`, и `else`;
- `if ... then ... else ...` возвращает значение, которое можно использовать, например, присвоить переменной или передать в функцию;
- обе ветки (`then` и `else`) должны иметь один и тот же тип.

Пример:
```haskell
signum' :: Int -> Int
signum' x = if x > 0
            then 1
            else if x < 0
                 then -1
                 else 0
```

**Охраняющие (или охранные) выражения (guards)**
это удобный и читаемый способ определения функций с несколькими условиями. Они особенно полезны, когда нужно проверить несколько логических условий (например, в зависимости от значений аргументов), и выглядят гораздо элегантнее вложенных `if-then-else`.
При этом:
- Все ветки (результаты) должны иметь один и тот же тип.
- Если ни одно условие не выполнено и нет `otherwise` - функция завершится исключением (ошибка времени выполнения). Поэтому почти всегда следует добавлять `otherwise` в конец.

Пример:
```haskell
signum'' :: Int -> Int
signum'' x
  | x > 0     = 1
  | x < 0     = -1
  | otherwise = 0
```

**Сопоставление с образцом (pattern matching)** 
одна из самых мощных и характерных черт языка Haskell. Оно позволяет разбирать структуры данных (списки, кортежи, пользовательские типы и т.д.) прямо в определении функций, присваиваниях или ветвлениях, проверяя их форму и извлекая значения.
При этом:
- Порядок важен: сопоставление проверяется сверху вниз.
- Образцы должны быть исчерпывающими: если возможен случай, не охваченный ни одним паттерном, компилятор выдаст предупреждение (или ошибка, если включён `-Werror`).
- Нельзя использовать произвольные функции в образцах - только конструкторы данных, константы и переменные.

Пример:
```haskell
isEmpty :: [a] -> Bool
isEmpty [] = True
isEmpty _  = False
```
