#+title: Основы

=Полезные ссылки=

[[ha][https://hackage.haskell.org/]]
https://hackage.haskell.org/packages/
https://hoogle.haskell.org/
https://hackage.haskell.org/packages/browse

=Простой проект=

#+begin_src haskell
module Main where

main :: IO ()
main = do
  putStrLn "hello"
#+end_src

=Объявление функции=

#+begin_src haskell
square :: Int -> Int -> Int
square a b = a * b
#+end_src

=Ветвление=

#+begin_src haskell
checkLocalhost :: String -> String
checkLocalhost ip =
  -- True или False?
  if ip == "127.0.0.1" || ip == "0.0.0.0"
    -- Если True - идёт туда...
    then "It's a localhost!"
    -- А если False - сюда...
    else "No, it's not a localhost."
#+end_src

=Pattern matching=

#+begin_src haskell
{-# LANGUAGE MultiWayIf #-} -- включаем расширение
...
analyzeGold :: Int -> String
analyzeGold standard =
  if | standard == 999 -> "Wow! 999 standard!"
     | standard == 750 -> "Great! 750 standard."
     | standard == 585 -> "Not bad! 585 standard."
     | otherwise -> "I don't know such a standard..."
#+end_src

#+begin_src haskell
analyzeGold :: Int -> String
analyzeGold standard
  | standard == 999 = "Wow! 999 standard!"
  | standard == 750 = "Great! 750 standard."
  | standard == 585 = "Not bad! 585 standard."
  | otherwise = "I don't know such a standard..."
#+end_src

#+begin_src haskell
analyzeGold :: Int -> String  -- Одно объявление.
-- И множество определений...
analyzeGold 999 = "Wow! 999 standard!"
analyzeGold 750 = "Great! 750 standard."
analyzeGold 585 = "Not bad! 585 standard."
analyzeGold _   = "I don't know such a standard..."
#+end_src

#+begin_src haskell
analyzeGold standard =
  case standard of
    999 -> "Wow! 999 standard!"
    750 -> "Great! 750 standard."
    585 -> "Not bad! 585 standard."
    _   -> "I don't know such a standard..."
#+end_src

=let=

#+begin_src haskell
calculateTime :: Int -> Int
calculateTime timeInS =
  let threshold  = 40
      correction = 120
      delta      = 8
  in
  if | timeInS <  threshold -> timeInS + correction
     | timeInS >= threshold -> timeInS + delta + correction
#+end_src

=where=

#+begin_src haskell
calculateTime :: Int -> Int
calculateTime timeInS =
  if | timeInS < threshold -> timeInS + correction
     | otherwise -> timeInS +
                    delta +
                    correction
  where
    threshold  = 40
    correction = 120
    delta      = 8
#+end_src

=Инфиксная форма оператора=

#+begin_src haskell
isEqualTo :: Int -> Int -> Bool
isEqualTo x y = x == y
...
if isEqualTo code1 code2 then ... else ...
...
if code1 `isEqualTo` code2 then ... else ...
#+end_src

=Списки=

#+begin_src haskell
[1, 2, 3]
[1.3, 45.7899]
["TCP", "UDP", "DCCP", "SCTP"]
#+end_src

Типы списков:
#+begin_src haskell
[Int]     -- Список целых чисел
[Char]    -- Список символов
[String]  -- Список строк
[[String]]  -- Список списков строк
#+end_src

=Действия над списками=

#+begin_src haskell
main :: IO ()
main = putStrLn (head ["Vim", "Emacs", "Atom"])
#+end_src
~head~ возвращает голову списка
~tail~ формирует другой список, представляющий собою всё от первоначального списка, кроме головы
~length~ возвращает длину списка
Стандартный оператор ~:~ добавляет значение, являющееся левым операндом, в начало списка, являющегося правым операндом.

=Синоним типа=

#+begin_src haskell
type String = [Char]
#+end_src

=Перечисление=

#+begin_src haskell
[1..10] = [1,2,3,4,5,6,7,8,9,10]
[2,4..10] = [2,4,6,8,10]
[9,8..1] = [9,8,7,6,5,4,3,2,1]
['a'..'z'] = "abcdefghijklmnopqrstuvwxyz"
#+end_src

=Кортеж=

#+begin_src haskell
("Haskell", 2010) -- тип кортежа (String, Int)
#+end_src
Стандартные функции ~fst~ и ~snd~ возвращают первый и второй элемент кортежа соответственно

#+begin_src haskell
type Patient = (UUID, FullName, Email, Age)
-- взять часть информации кортежа
patientEmail (_, _, email, _) = email
#+end_src

=Пакет tuple=

#+begin_src haskell
import Data.Tuple.Select

main :: IO ()
main = print (sel4 (123, 7, "hydra", "DC:4", 44, "12.04"))
#+end_src
Функция ~sel4~ из модуля ~Data.Tuple.Select~ извлекает четвёртый по счёту элемент кортежа.

#+begin_src haskell
import Data.Tuple.Update

main :: IO ()
main = print (upd2 2 ("si", 45))
#+end_src
Функция ~upd2~ обновляет второй элемент кортежа. Естественно, по причине неизменности кортежа, никакого обновления тут не происходит, но выглядит симпатично.

=Лямбда функции=

#+begin_src haskell
main :: IO ()
main = print (mul 10 4)
  where mul = \x y -> x * y -- :: Int -> Int -> Int
#+end_src

=Композиция и применение=

#+begin_src haskell
main :: IO ()
main = putStrLn . checkLocalhost $ "173.194.22.100"


logWarn :: String -> String
logWarn = warning . correctSpaces . asciiOnly
#+end_src

Оператор ~.~ — это оператор композиции функций (англ. ~function composition~), а оператор ~$~ — это оператор применения (англ. ~application operator~).
~Оператор композиции:~
#+begin_src haskell
(.) f g = \x -> f (g x)
#+end_src

=Собственный оператор композиции=

#+begin_src haskell
(<+>) f g = \x -> f (g x)
(<+>) f g = f . g
f <+> g = f . g
#+end_src

=Отображение (map)=

#+begin_src haskell
map :: (a -> b) -> [a] -> [b]
#+end_src

#+begin_src haskell
import Data.Char

toUpperCase :: String -> String
toUpperCase str = map toUpper str

main :: IO ()
main = putStrLn . toUpperCase $ "haskell.org" --HASKELL.ORG
#+end_src

~toUpper~ переводит символ в верхний регистр
~show~ переводит свой аргумент в строку

в качестве аргумента функции map мы можем использовать и
 собственные функции:

#+begin_src haskell
ten :: [Double] -> [Double]
ten = map (\n -> n * 10)

main :: IO ()
main = print . ten $ [1.2, 1,4, 1.6] --[12.0,10.0,40.0,16.0]
#+end_src

#+begin_src haskell
main :: IO ()
main = print . ten $ [1.1, 2.2, 4.4]
  where
    ten = map (\n -> n * 10)
#+end_src

=Частичное применение=

#+begin_src haskell
main :: IO ()
main = putStrLn result
  where
    first  = replace "http"
    second = first   "https"
    result = second  "http://google.com"
#+end_src

Тип выражения ~first — String -> String -> String~, оно явилось
результатом частичного применения функции ~replace~ к первому аргументу, строке "http". Тип выражения ~second — String -> String~, оно явилось результатом вторичного частичного применения функции ~first~ к уже второму аргументу, строке ~"https"~. И наконец, применив функцию ~second~ к третьему аргументу, строке ~"http://google.com"~, мы наконец-то получаем
конечный результат, ассоциированный с выражением ~result~.

=Композиция для отображения=

#+begin_src haskell
import Data.Char

pretty :: [String] -> [String]
pretty = map (stars . big)
  where
    big = map toUpper
    stars = \s -> "* " ++ s ++ " *"

main :: IO ()
main = print . pretty $ ["haskell", "lisp", "coq"]
#+end_src

=Импорт библиотек=

Чтобы использовать сторонюю библиотеку нужно включить её в проект.
Для этого в файл ~имя_проекта.cabal~ в корне проекта в секцию ~build-depends:~.
После этого импортировать в файле ~.hs~.

#+begin_src haskell
import Data.Text.IO -- импорт всего пакета
import    Data.Text.IO  as   TIO -- импорт пакета под алиасом TIO
import qualified Data.Text.IO as TIO -- qualified заставляет обязательно указывать имя пакета при вызове
import Data.Text (pack) -- импорт только функции pack
import Data.Text.IO hiding (putStrLn) -- импорт с исключением функции putStrLn
#+end_src
