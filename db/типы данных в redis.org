#+title: Типы Данных В Redis

* Строки (String)
Строка Redis — это последовательность байтов, которая может хранить последовательность байтов, включая текст, объекты, двоичные массивы.
Максимальный размер равен 512 мегабайт в одной строке.
Строка Redis также может использоваться в качестве ключа Redis для сопоставления строки с другой строкой. Строковые типы данных полезны в различных сценариях использования, например: кэширование фрагментов HTML или разных страниц.
#+begin_src go
func main() {
	key := "string:key"
	if cache.Set(key, "As the simplest type of Redis, the bottom layer has only one data structure, which is simple dynamic string (SDS).") != nil {
		fmt.Println("Cache settings error")
	}
	value, err := cache.Get(key)
	if err != nil {
		fmt.Println("get cache errors")
	}
	fmt.Printf("Get the cache value: %s \ n", value)
}
#+end_src

Как Redis хранит строковые типы данных?
- Redis использует механизм хранения данных в виде пар «ключ-значение», где уникальный ключ связан со строковым значением.
- Ключи хранятся в виде двоичных данных, а связанные со строками значения могут содержать текстовые или двоичные данные.

* Хэш-таблица
Хэши Redis используются для хранения списка из нескольких пар «ключ-значение». Они используются для сопоставления одной строки с другой. Они также могут использоваться для представления объектов.

Базовые команда, используемые в структуре хэш-данных в Redis:
- HSET — эта команда устанавливает пару «ключ-значение» в хэше.
- HGET — эта команда возвращает значение указанного ключа.
- HMGET — эта команда возвращает все ключи и значения, присутствующие в хэш-таблице.
- HINCRBY — эта команда увеличивает значение указанного ключа.

#+begin_src go
func main() {
	key := "string:hash"
	cache.HSet(key, "name", "Zhang San")
	cache.HSet(key, "phone", "18234554345")
	cache.HSet(key, "age", "28")
	// Get all hash objects
	all, _ := cache.HGetAll(key)
	fmt.Println(all)
	// Modify the existing fields
	cache.HSet(key, "name", "Li Si")
	// Get the specified field
	name, _ := cache.HGet(key, "name")
	fmt.Println(name)
	existsName, _ := cache.HExists(key, "name")
	existsId, _ := cache.HExists(key, "id")
	fmt.Printf("Whether there is %v \ n" in the name field, existsName)
	fmt.Printf("Is there any %v \ n" in the ID field?, existsId)
	cache.HDel(key, "name")
	existsName, _ = cache.HExists(key, "name")
	fmt.Printf("Whether there is %v \ n" in the name field, existsName)
	getAll, _ := cache.HGetAll(key)
	fmt.Println(getAll)
}
#+end_src

Как Redis хранит хэш-типы данных?
- Хэши реализованы в Redis как хранилища «ключ-значение».
- Хэш можно рассматривать как карту или словарь, где один ключ сопоставляется с несколькими парами «поле-значение».
- Хэши подходят для хранения структурированных данных.

* Cписок (List)
Набор элементов доступных в порядке добавления.

Базовые команды, используемые в структуре данных списка в Redis:
- LPUSH — эта команда добавляет новый элемент в начало списка.
- RPUSH — эта команда добавляет новый элемент в конец списка.
- LPOP — эта команда удаляет и возвращает элемент из начала списка.
- RPOP — эта команда удаляет и возвращает элемент из конца списка.
- LLEN — эта команда возвращает длину списка.
- LMOVE — эта команда автоматически перемещает элементы из одного списка в другой.
- LTRIM — эта команда сокращает список до указанного диапазона элементов.

#+begin_src go
func main() {
	key := "string:list"
	err := cache.RedisCache.LPush(key, "A", "B", "C", 20, "D", "E", "F").Err()
	if err != nil {
		fmt.Println("Cache settings error", err)
	}
	value, err := cache.RPop(key)
	if err != nil {
		fmt.Println("get cache errors")
	}
	fmt.Printf("Get the cache value: %s \ n", value)

	lLen, _ := cache.LLen(key)
	fmt.Printf("Collection data length:%d \ n", lLen)
	lRange, _ := cache.LRange(key, 0, 3)
	fmt.Println(lRange)
}
#+end_src

Как Redis хранит типы данных списка?
- Списки в Redis реализованы в виде двусвязного списка значений.
- Каждый список имеет уникальный ключ, а элементы хранятся в том порядке, в котором они были добавлены.
- Списки обычно используются для реализации очередей, брокеров сообщений и многого другого.

* Множество (Set)
Неупорядоченная коллекция уникальных строк.
Её можно использовать для поиска уникальных элементов в списке, а также для пересечения, объединения и разности множеств.
Максимальный размер набора Redis составляет 2^32 – 1 (4 294 967 295) элементов.

Основные команды, используемые для задания типов данных в Redis
- SADD: эта команда используется для добавления нового элемента в набор.
- SREM: эта команда удаляет указанный элемент из набора.
- SISMEMBER: эта команда проверяет строку на принадлежность к набору.
- SINTER: эта команда возвращает пересечение списков.
- SCARD: эта команда возвращает размер набора.
- SMEMBERS: эта команда возвращает все элементы набора, значение которого хранится по ключу.
- SDIFF: возвращает разницу множеств
- SINTER: возвращает пересечение множеств
- SUNION: возвращает объединение множеств

#+begin_src go
func main() {
	key := "string:set"
	cache.RedisCache.SAdd(key, "phone")
	err2 := cache.RedisCache.SAdd(key, "hahh").Err()
	if err2 != nil {
		fmt.Println(err2)
		return
	}
	// Get all hash objects
	all, _ := cache.SCard(key)
	fmt.Println(all)
	members, err2 := cache.SMembers(key)
	fmt.Println(members)
}
#+end_src

Как Redis хранит установленные типы данных?
- Наборы реализованы как неупорядоченная коллекция уникальных элементов.
- Redis использует оптимизированную структуру данных, чтобы гарантировать уникальность элементов в наборе.
- Операции с наборами, такие как объединение, пересечение и разность, являются эффективными.

* Упорядоченное множество (Sorted set)
Упорядоченная коллекция уникальных строк, хранящихся в отсортированном виде в соответствии с ассоциированным ключом.
Если два или более ключа имеют одинаковое значение, строки упорядочиваются в лексикографическом порядке.
Это похоже на Redis Set, с той лишь разницей, что Sorted Set представляет данные в отсортированном или упорядоченном виде.

Основные команды, используемые для задания типов данных в Redis:
- ZADD: эта команда добавит элемент в упорядоченный набор, если элемент уже присутствует, то значение ключа будет обновлено.
- ZRANGE: эта команда возвращает элементы отсортированного набора в заданном диапазоне.
- ZRANK: эта команда возвращает ранг указанного элемента в отсортированном (по возрастанию) списке
- ZREVRANK: эта команда возвращает ранг указанного элемента в отсортированном (по убыванию) списке

#+begin_src go
func main() {
	key := "string:zset"
	set := []redis.Z{
		{Score: 80, Member: "Java"},
		{Score: 90, Member: "Python"},
		{Score: 95, Member: "Golang"},
		{Score: 98, Member: "PHP"},
	}
	err := cache.ZAdd(key, set)
	if err != nil {
		fmt.Println(err)
	}
	scores, _ := cache.ZRevRangeWithScores(key, 0, 2)
	fmt.Println(scores)
	cache.ZIncrBy(key, 5, "Golang")
	scores, _ = cache.ZRevRangeWithScores(key, 0, 2)
	fmt.Println("After the points ----")
	fmt.Println(scores)
}
#+end_src

Как Redis Хранит отсортированные заданные типы данных?
- Отсортированные множества сочетают в себе свойства множеств и упорядоченных списков.
- Каждый элемент в отсортированном множестве связан со значением, и элементы хранятся в порядке возрастания их значений.
- Отсортированные множества полезны для ранжирования и составления рейтингов.

* Потоки (Streams)
Поток Redis — это структура данных, которая работает как журнал с возможностью только добавления, но также реализует несколько операций, позволяющих преодолеть некоторые ограничения обычного журнала с возможностью только добавления. К ним относятся произвольный доступ за время O(1) и сложные стратегии потребления, такие как группы потребителей.

Основные команды, используемые в потоках в Redis:
- XADD — эта команда добавит элемент в поток.
- XREAD — эта команда прочитает одну или несколько записей.
- XRANGE — эта команда возвращает записи в заданном диапазоне.
- XLEN — эта команда возвращает длину потока.

Как Redis хранит типы данных Streams?
- Потоки реализованы в виде журнала с возможностью только добавления записей.
- Каждый поток имеет уникальный ключ и состоит из последовательности записей с уникальными идентификаторами.
- Потоки используются для хранения и обработки данных на основе событий и журналов.

* HyperLogLog
HyperLogLog — это вероятностная структура данных, которая оценивает мощность множества.
Будучи вероятностной структурой данных, HyperLogLog жертвует идеальной точностью ради эффективного использования пространства.

Основные команды, используемые в HyperLogLog в Redis:
- PFADD: Эта команда добавит элемент в HyperLogLog.
- PFADD: Эта команда подсчитает количество элементов в наборе.
- PFMERGE: Эта команда объединит два или более HyperLog в один.

Как Redis хранит типы данных HyperLogLog?
- HyperLogLogs используют вероятностные структуры данных для оценки мощности (количества уникальных элементов) множества.
- Они используют минимальный объём памяти для получения приблизительных результатов.

* Растровые изображения в Redis
Растровые изображения — это не фактический тип данных, а набор битовых операций, определённых для типа String, который рассматривается как битовый вектор.
Поскольку строки являются двоичными безопасными объектами и их максимальная длина составляет 512 МБ, они подходят для установки до 2^32 различных битов.

Основные команды, используемые в растровых изображениях в Redis:
- SETBIT: Эта команда используется для установки бита в 0 из 1 и в 1 из 0.
- GETBIT: Эта команда используется для возврата значения бита с заданным смещением.
- BITOP: Эта команда используется для выполнения побитовых операций с одной или несколькими строками.

Как Redis хранит типы данных растровых изображений?
- Растровые изображения реализованы в виде массива битов.
- Redis предоставляет операции на уровне битов для установки, очистки и управления отдельными битами в растровом изображении.
- Растровые изображения используются в различных приложениях, включая аналитику и отслеживание поведения пользователей.

* Битовые поля в Redis
Битовые поля Redis позволяют устанавливать, увеличивать и получать целочисленные значения с любым количеством бит.
Например, вы можете работать с любыми числами — от 63-битных чисел со знаком до 1-битных целых чисел без знака.

Основные команды, используемые в битовых полях в Redis:
- BITFIELD : эта команда атомарно устанавливает, увеличивает и считывает одно или несколько значений.
- BITFIELD_RO: эта команда является вариантом BITFIELD

* Вероятностные типы
Вероятностные структуры данных используются для получения приблизительных ответов или оценок для определённых операций с меньшим использованием памяти по сравнению с точными структурами данных.
Одной из наиболее часто используемых вероятностных структур данных в Redis является =HyperLogLog= (HLL). Она используется для оценки мощности (количества уникальных элементов) множества.
Redis также предлагает другую вероятностную структуру данных под названием =фильтры Блума=. Она проверяет наличие элемента в множестве. Фильтры Блума полезны для быстрой проверки принадлежности к большому набору данных без необходимости хранить весь набор данных в памяти. Фильтры Блума — это вероятностная структура данных, которая проверяет наличие элемента в наборе.

* Геопространственные индексы в Redis
Геопространственные индексы Redis помогают нам хранить координаты и искать их. Эта структура данных полезна для поиска ближайших точек.

Основные команды, используемые в геопространственной индексации в Redis:
- GEOADD— эта команда добавляет местоположение в заданную геопространственную команду.
- GEOSEARCH- эта команда возвращает местоположение заданной точки.

* Временные ряды в Redis
Чтобы создать структуру данных временных рядов в Redis, вы можете использовать отсортированные наборы (Zsets) или потоки в зависимости от ваших конкретных требований.

- Отсортированные наборы (Z-наборы):Вы можете использовать отсортированный набор Redis для хранения данных временных рядов, где значение представляет собой метку времени, а элемент — точку данных.
- Потоки:Потоки Redis — ещё один вариант для управления данными временных рядов. Потоки больше подходят для потоковой передачи событий в реальном времени и ведения журналов.

Redis эффективно управляет памятью для этих типов данных и предлагает различные команды для выполнения операций с ними. Кроме того, Redis обеспечивает сохранение данных с помощью таких механизмов, как моментальные снимки и журналы упреждающей записи, гарантируя надёжность данных.

* TODO
- [ ] - Добавить пример в потоки
- [ ] - Добавить пример в hyperloglog
- [ ] - Добавить пример в геоданные
- [ ] - Добавить пример в фильтр блума
