#+title: Типы Данных В Redis

* Строки (String)
Строка Redis — это последовательность байтов, которая может хранить последовательность байтов, включая текст, объекты, двоичные массивы.
Максимальный размер равен 512 мегабайт в одной строке.
Строка Redis также может использоваться в качестве ключа Redis для сопоставления строки с другой строкой. Строковые типы данных полезны в различных сценариях использования, например: кэширование фрагментов HTML или разных страниц.
#+begin_src go
func main() {
	key := "string:key"
	if cache.Set(key, "As the simplest type of Redis, the bottom layer has only one data structure, which is simple dynamic string (SDS).") != nil {
		fmt.Println("Cache settings error")
	}
	value, err := cache.Get(key)
	if err != nil {
		fmt.Println("get cache errors")
	}
	fmt.Printf("Get the cache value: %s \ n", value)
}
#+end_src

Как Redis хранит строковые типы данных?
- Redis использует механизм хранения данных в виде пар «ключ-значение», где уникальный ключ связан со строковым значением.
- Ключи хранятся в виде двоичных данных, а связанные со строками значения могут содержать текстовые или двоичные данные.

* Хэш-таблица
Хэши Redis используются для хранения списка из нескольких пар «ключ-значение». Они используются для сопоставления одной строки с другой. Они также могут использоваться для представления объектов.

Базовые команда, используемые в структуре хэш-данных в Redis:
- HSET — эта команда устанавливает пару «ключ-значение» в хэше.
- HGET — эта команда возвращает значение указанного ключа.
- HMGET — эта команда возвращает все ключи и значения, присутствующие в хэш-таблице.
- HINCRBY — эта команда увеличивает значение указанного ключа.

#+begin_src go
func main() {
	key := "string:hash"
	cache.HSet(key, "name", "Zhang San")
	cache.HSet(key, "phone", "18234554345")
	cache.HSet(key, "age", "28")
	// Get all hash objects
	all, _ := cache.HGetAll(key)
	fmt.Println(all)
	// Modify the existing fields
	cache.HSet(key, "name", "Li Si")
	// Get the specified field
	name, _ := cache.HGet(key, "name")
	fmt.Println(name)
	existsName, _ := cache.HExists(key, "name")
	existsId, _ := cache.HExists(key, "id")
	fmt.Printf("Whether there is %v \ n" in the name field, existsName)
	fmt.Printf("Is there any %v \ n" in the ID field?, existsId)
	cache.HDel(key, "name")
	existsName, _ = cache.HExists(key, "name")
	fmt.Printf("Whether there is %v \ n" in the name field, existsName)
	getAll, _ := cache.HGetAll(key)
	fmt.Println(getAll)
}
#+end_src

Как Redis хранит хэш-типы данных?
- Хэши реализованы в Redis как хранилища «ключ-значение».
- Хэш можно рассматривать как карту или словарь, где один ключ сопоставляется с несколькими парами «поле-значение».
- Хэши подходят для хранения структурированных данных.

* Cписок (List)
Набор элементов доступных в порядке добавления.

Базовые команды, используемые в структуре данных списка в Redis:
- LPUSH — эта команда добавляет новый элемент в начало списка.
- RPUSH — эта команда добавляет новый элемент в конец списка.
- LPOP — эта команда удаляет и возвращает элемент из начала списка.
- RPOP — эта команда удаляет и возвращает элемент из конца списка.
- LLEN — эта команда возвращает длину списка.
- LMOVE — эта команда автоматически перемещает элементы из одного списка в другой.
- LTRIM — эта команда сокращает список до указанного диапазона элементов.

#+begin_src go
func main() {
	key := "string:list"
	err := cache.RedisCache.LPush(key, "A", "B", "C", 20, "D", "E", "F").Err()
	if err != nil {
		fmt.Println("Cache settings error", err)
	}
	value, err := cache.RPop(key)
	if err != nil {
		fmt.Println("get cache errors")
	}
	fmt.Printf("Get the cache value: %s \ n", value)

	lLen, _ := cache.LLen(key)
	fmt.Printf("Collection data length:%d \ n", lLen)
	lRange, _ := cache.LRange(key, 0, 3)
	fmt.Println(lRange)
}
#+end_src

Как Redis хранит типы данных списка?
- Списки в Redis реализованы в виде двусвязного списка значений.
- Каждый список имеет уникальный ключ, а элементы хранятся в том порядке, в котором они были добавлены.
- Списки обычно используются для реализации очередей, брокеров сообщений и многого другого.

* Множество (Set)
Неупорядоченная коллекция уникальных строк.
Её можно использовать для поиска уникальных элементов в списке, а также для пересечения, объединения и разности множеств.
Максимальный размер набора Redis составляет 2^32 – 1 (4 294 967 295) элементов.

Основные команды, используемые для задания типов данных в Redis
- SADD: эта команда используется для добавления нового элемента в набор.
- SREM: эта команда удаляет указанный элемент из набора.
- SISMEMBER: эта команда проверяет строку на принадлежность к набору.
- SINTER: эта команда возвращает пересечение списков.
- SCARD: эта команда возвращает размер набора.
- SMEMBERS: эта команда возвращает все элементы набора, значение которого хранится по ключу.
- SDIFF: возвращает разницу множеств
- SINTER: возвращает пересечение множеств
- SUNION: возвращает объединение множеств

#+begin_src go
func main() {
	key := "string:set"
	cache.RedisCache.SAdd(key, "phone")
	err2 := cache.RedisCache.SAdd(key, "hahh").Err()
	if err2 != nil {
		fmt.Println(err2)
		return
	}
	// Get all hash objects
	all, _ := cache.SCard(key)
	fmt.Println(all)
	members, err2 := cache.SMembers(key)
	fmt.Println(members)
}
#+end_src

Как Redis хранит установленные типы данных?
- Наборы реализованы как неупорядоченная коллекция уникальных элементов.
- Redis использует оптимизированную структуру данных, чтобы гарантировать уникальность элементов в наборе.
- Операции с наборами, такие как объединение, пересечение и разность, являются эффективными.

* Упорядоченное множество (Sorted set)
Упорядоченная коллекция уникальных строк, хранящихся в отсортированном виде в соответствии с ассоциированным ключом.
Если два или более ключа имеют одинаковое значение, строки упорядочиваются в лексикографическом порядке.
Это похоже на Redis Set, с той лишь разницей, что Sorted Set представляет данные в отсортированном или упорядоченном виде.

Основные команды, используемые для задания типов данных в Redis:
- ZADD: эта команда добавит элемент в упорядоченный набор, если элемент уже присутствует, то значение ключа будет обновлено.
- ZRANGE: эта команда возвращает элементы отсортированного набора в заданном диапазоне.
- ZRANK: эта команда возвращает ранг указанного элемента в отсортированном (по возрастанию) списке
- ZREVRANK: эта команда возвращает ранг указанного элемента в отсортированном (по убыванию) списке

#+begin_src go
func main() {
	key := "string:zset"
	set := []redis.Z{
		{Score: 80, Member: "Java"},
		{Score: 90, Member: "Python"},
		{Score: 95, Member: "Golang"},
		{Score: 98, Member: "PHP"},
	}
	err := cache.ZAdd(key, set)
	if err != nil {
		fmt.Println(err)
	}
	scores, _ := cache.ZRevRangeWithScores(key, 0, 2)
	fmt.Println(scores)
	cache.ZIncrBy(key, 5, "Golang")
	scores, _ = cache.ZRevRangeWithScores(key, 0, 2)
	fmt.Println("After the points ----")
	fmt.Println(scores)
}
#+end_src

Как Redis Хранит отсортированные заданные типы данных?
- Отсортированные множества сочетают в себе свойства множеств и упорядоченных списков.
- Каждый элемент в отсортированном множестве связан со значением, и элементы хранятся в порядке возрастания их значений.
- Отсортированные множества полезны для ранжирования и составления рейтингов.

* Потоки (Streams)
Поток Redis — это структура данных, которая работает как журнал с возможностью только добавления, но также реализует несколько операций, позволяющих преодолеть некоторые ограничения обычного журнала с возможностью только добавления. К ним относятся произвольный доступ за время O(1) и сложные стратегии потребления, такие как группы потребителей.

Основные команды, используемые в потоках в Redis:
- XADD — эта команда добавит элемент в поток.
- XREAD — эта команда прочитает одну или несколько записей.
- XRANGE — эта команда возвращает записи в заданном диапазоне.
- XLEN — эта команда возвращает длину потока.

Как Redis хранит типы данных Streams?
- Потоки реализованы в виде журнала с возможностью только добавления записей.
- Каждый поток имеет уникальный ключ и состоит из последовательности записей с уникальными идентификаторами.
- Потоки используются для хранения и обработки данных на основе событий и журналов.

* HyperLogLog
HyperLogLog — это вероятностная структура данных, которая оценивает мощность множества.
Будучи вероятностной структурой данных, HyperLogLog жертвует идеальной точностью ради эффективного использования пространства.

Основные команды, используемые в HyperLogLog в Redis:
- PFADD: Эта команда добавит элемент в HyperLogLog.
- PFCOUNT: Эта команда подсчитает количество элементов в наборе.
- PFMERGE: Эта команда объединит два или более HyperLog в один.

#+begin_src go
package main

import (
	"context"
	"fmt"

	"github.com/redis/go-redis/v9"
)

func main() {
	// Подключаемся к Redis
	rdb := redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "",
		DB:       0,
	})

	ctx := context.Background()
	// проверяем соединение
	err := rdb.Ping(ctx).Err()
	if err != nil {
		panic(err)
	}

	// Очищаем все данные перед началом (опционально)
	rdb.FlushAll(ctx)

	hll_name := "unique_usr"
	// добавляем элементы
	for _, i := range []string{"usr1", "usr2", "usr3", "usr1"} {
		err := rdb.PFAdd(ctx, hll_name, i).Err()
		if err != nil {
			panic(err)
		}
	}

	// Получаем оценку количества уникальных элементов
	count, err := rdb.PFCount(ctx, hll_name).Result()
	if err != nil {
		panic(err)
	}
	fmt.Println("count of unique elements = ", count)
}
#+end_src

Как Redis хранит типы данных HyperLogLog?
- HyperLogLogs используют вероятностные структуры данных для оценки мощности (количества уникальных элементов) множества.
- Они используют минимальный объём памяти для получения приблизительных результатов.

* Растровые изображения в Redis
Растровые изображения — это не фактический тип данных, а набор битовых операций, определённых для типа String, который рассматривается как битовый вектор.
Поскольку строки являются двоичными безопасными объектами и их максимальная длина составляет 512 МБ, они подходят для установки до 2^32 различных битов.

Основные команды, используемые в растровых изображениях в Redis:
- SETBIT: Эта команда используется для установки бита в 0 из 1 и в 1 из 0.
- GETBIT: Эта команда используется для возврата значения бита с заданным смещением.
- BITOP: Эта команда используется для выполнения побитовых операций с одной или несколькими строками.

Как Redis хранит типы данных растровых изображений?
- Растровые изображения реализованы в виде массива битов.
- Redis предоставляет операции на уровне битов для установки, очистки и управления отдельными битами в растровом изображении.
- Растровые изображения используются в различных приложениях, включая аналитику и отслеживание поведения пользователей.

* Битовые поля в Redis
Битовые поля Redis позволяют устанавливать, увеличивать и получать целочисленные значения с любым количеством бит.
Например, вы можете работать с любыми числами — от 63-битных чисел со знаком до 1-битных целых чисел без знака.

Основные команды, используемые в битовых полях в Redis:
- BITFIELD : эта команда атомарно устанавливает, увеличивает и считывает одно или несколько значений.
- BITFIELD_RO: эта команда является вариантом BITFIELD

* BloomFilter
Redis также предлагает вероятностную структуру данных под названием =фильтры Блума=. Она проверяет наличие элемента в множестве. Фильтры Блума полезны для быстрой проверки принадлежности к большому набору данных без необходимости хранить весь набор данных в памяти.
Сначала нужно установить и активировать модель RedisBloom.
Для работы с фильтром Блума нужно установить либу v8:
#+begin_src
go get github.com/go-redis/redis/v8
#+end_src
#+begin_src go
package main

import (
	"context"
	"fmt"

	"github.com/go-redis/redis/v8"
)

func main() {
	rdb := redis.NewClient(&redis.Options{
		Addr: "localhost:6379"})

	filter_name := "bloom_filter"
	// ожидаемая емкость фильтра
	filter_cap := 1000
	// допустимая вероятность ложного срабатывания
	filter_err_rate := 0.01

	// Команда BF.RESERVE создает новый Bloom Filter
	ctx := context.Background()
	err := rdb.Do(ctx, "BF.RESERVE", filter_name, filter_err_rate, filter_cap).Err()
	if err != nil {
		panic(err)
	}

	// Добавляем элементы в Bloom Filter
	for _, i := range []string{"item1", "item2", "item3", "item4"} {
		res, err := rdb.Do(ctx, "BF.ADD", filter_name, i).Result()
		if err != nil {
			panic(err)
		}
		fmt.Println("Элемент '%s' добавлен в фильтр '%v'", i, res)
	}

	// Проверяем наличие элементов в Bloom Filter
	{
		exists, err := rdb.Do(ctx, "BF.EXISTS", filter_name, "item1").Result()
		if err != nil {
			panic(err)
		}
		fmt.Println("Элемент '%s' содержится: %v", "item1", exists)
	}
	{
		exists, err := rdb.Do(ctx, "BF.EXISTS", filter_name, "item7").Result()
		if err != nil {
			panic(err)
		}
		fmt.Println("Элемент '%s' содержится: %v", "item7", exists)
	}
}
#+end_src
* Геопространственные индексы в Redis
Геопространственные индексы Redis помогают нам хранить координаты и искать их. Эта структура данных полезна для поиска ближайших точек.

#+begin_src go
package main

import (
	"context"
	"fmt"

	"github.com/go-redis/redis/v8"
)

func main() {
	rdb := redis.NewClient(&redis.Options{
		Addr: "localhost:6379"})

	ctx := context.Background()
	// Очищаем все данные перед началом (опционально)
	rdb.FlushAll(ctx)

	// Добавляем геоданные в Redis
	locations := map[string]struct {
		longitude float64
		latitude  float64
	}{
		"location1": {longitude: 13.361389, latitude: 38.115556},
		"location2": {longitude: 15.087269, latitude: 37.502669},
		"location3": {longitude: 12.492465, latitude: 41.890251},
	}

	locations_key := "locations"
	for name, coord := range locations {
		err := rdb.GeoAdd(ctx, locations_key, &redis.GeoLocation{
			Name:      name,
			Longitude: coord.longitude,
			Latitude:  coord.latitude,
		}).Err()

		if err != nil {
			panic(err)
		}
	}

	// Выполняем поиск по радиусу
	longitude, latitude := 13.361389, 38.115556 // Координаты центра поиска
	radius := 200.0

	// GEORADIUS выполняет поиск по радиусу
	found, err := rdb.GeoRadius(ctx, locations_key, longitude, latitude, &redis.GeoRadiusQuery{
		Radius:    radius,
		WithCoord: true,
		WithDist:  true,
		// Count: 2, // можно задать количество выдачи
		// Sort: "DESC", // можно задать сортировку результатов
	}).Result()
	if err != nil {
		panic(err)
	}

	// Выводим результаты поиска
	for _, loc := range found {
		fmt.Printf("Имя: %s, Расстояние: %.2f м, Координаты: (%.6f, %.6f)\n",
			loc.Name, loc.Dist, loc.Longitude, loc.Latitude)
	}
}
#+end_src

Основные команды, используемые в геопространственной индексации в Redis:
- GEOADD - эта команда добавляет местоположение в заданную геопространственную команду.
- GEOSEARCH - эта команда возвращает местоположение заданной точки.
- GEORADIUS - позволяет выполнять поиск по радиусу

* Временные ряды в Redis
Чтобы создать структуру данных временных рядов в Redis, вы можете использовать отсортированные наборы (Zsets) или потоки в зависимости от ваших конкретных требований.

- Отсортированные наборы (Z-наборы):Вы можете использовать отсортированный набор Redis для хранения данных временных рядов, где значение представляет собой метку времени, а элемент — точку данных.
- Потоки:Потоки Redis — ещё один вариант для управления данными временных рядов. Потоки больше подходят для потоковой передачи событий в реальном времени и ведения журналов.

Redis эффективно управляет памятью для этих типов данных и предлагает различные команды для выполнения операций с ними. Кроме того, Redis обеспечивает сохранение данных с помощью таких механизмов, как моментальные снимки и журналы упреждающей записи, гарантируя надёжность данных.

* TODO
- [ ] - Добавить пример в потоки
