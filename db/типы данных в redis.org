#+title: Типы Данных В Redis

* Строки (String)
Строка Redis — это последовательность байтов, которая может хранить последовательность байтов, включая текст, объекты, двоичные массивы.
Максимальный размер равен 512 мегабайт в одной строке.
Строка Redis также может использоваться в качестве ключа Redis для сопоставления строки с другой строкой. Строковые типы данных полезны в различных сценариях использования, например: кэширование фрагментов HTML или разных страниц.
#+begin_src go
func main() {
	key := "string:key"
	if cache.Set(key, "As the simplest type of Redis, the bottom layer has only one data structure, which is simple dynamic string (SDS).") != nil {
		fmt.Println("Cache settings error")
	}
	value, err := cache.Get(key)
	if err != nil {
		fmt.Println("get cache errors")
	}
	fmt.Printf("Get the cache value: %s \ n", value)
}
#+end_src

Как Redis хранит строковые типы данных?
- Redis использует механизм хранения данных в виде пар «ключ-значение», где уникальный ключ связан со строковым значением.
- Ключи хранятся в виде двоичных данных, а связанные со строками значения могут содержать текстовые или двоичные данные.

* Хэш-таблица
Хэши Redis используются для хранения списка из нескольких пар «ключ-значение». Они используются для сопоставления одной строки с другой. Они также могут использоваться для представления объектов.

Базовые команда, используемые в структуре хэш-данных в Redis:
- HSET — эта команда устанавливает пару «ключ-значение» в хэше.
- HGET — эта команда возвращает значение указанного ключа.
- HMGET — эта команда возвращает все ключи и значения, присутствующие в хэш-таблице.
- HINCRBY — эта команда увеличивает значение указанного ключа.

#+begin_src go
func main() {
	key := "string:hash"
	cache.HSet(key, "name", "Zhang San")
	cache.HSet(key, "phone", "18234554345")
	cache.HSet(key, "age", "28")
	// Get all hash objects
	all, _ := cache.HGetAll(key)
	fmt.Println(all)
	// Modify the existing fields
	cache.HSet(key, "name", "Li Si")
	// Get the specified field
	name, _ := cache.HGet(key, "name")
	fmt.Println(name)
	existsName, _ := cache.HExists(key, "name")
	existsId, _ := cache.HExists(key, "id")
	fmt.Printf("Whether there is %v \ n" in the name field, existsName)
	fmt.Printf("Is there any %v \ n" in the ID field?, existsId)
	cache.HDel(key, "name")
	existsName, _ = cache.HExists(key, "name")
	fmt.Printf("Whether there is %v \ n" in the name field, existsName)
	getAll, _ := cache.HGetAll(key)
	fmt.Println(getAll)
}
#+end_src

Как Redis хранит хэш-типы данных?
- Хэши реализованы в Redis как хранилища «ключ-значение».
- Хэш можно рассматривать как карту или словарь, где один ключ сопоставляется с несколькими парами «поле-значение».
- Хэши подходят для хранения структурированных данных.

* Cписок (List)
Набор элементов доступных в порядке добавления.

Базовые команды, используемые в структуре данных списка в Redis:
- LPUSH — эта команда добавляет новый элемент в начало списка.
- RPUSH — эта команда добавляет новый элемент в конец списка.
- LPOP — эта команда удаляет и возвращает элемент из начала списка.
- RPOP — эта команда удаляет и возвращает элемент из конца списка.
- LLEN — эта команда возвращает длину списка.
- LMOVE — эта команда автоматически перемещает элементы из одного списка в другой.
- LTRIM — эта команда сокращает список до указанного диапазона элементов.

#+begin_src go
func main() {
	key := "string:list"
	err := cache.RedisCache.LPush(key, "A", "B", "C", 20, "D", "E", "F").Err()
	if err != nil {
		fmt.Println("Cache settings error", err)
	}
	value, err := cache.RPop(key)
	if err != nil {
		fmt.Println("get cache errors")
	}
	fmt.Printf("Get the cache value: %s \ n", value)

	lLen, _ := cache.LLen(key)
	fmt.Printf("Collection data length:%d \ n", lLen)
	lRange, _ := cache.LRange(key, 0, 3)
	fmt.Println(lRange)
}
#+end_src

Как Redis хранит типы данных списка?
- Списки в Redis реализованы в виде двусвязного списка значений.
- Каждый список имеет уникальный ключ, а элементы хранятся в том порядке, в котором они были добавлены.
- Списки обычно используются для реализации очередей, брокеров сообщений и многого другого.

* Множество (Set)
Неупорядоченная коллекция уникальных строк.
Её можно использовать для поиска уникальных элементов в списке, а также для пересечения, объединения и разности множеств.
Максимальный размер набора Redis составляет 2^32 – 1 (4 294 967 295) элементов.

Основные команды, используемые для задания типов данных в Redis
- SADD: эта команда используется для добавления нового элемента в набор.
- SREM: эта команда удаляет указанный элемент из набора.
- SISMEMBER: эта команда проверяет строку на принадлежность к набору.
- SINTER: эта команда возвращает пересечение списков.
- SCARD: эта команда возвращает размер набора.
- SMEMBERS: эта команда возвращает все элементы набора, значение которого хранится по ключу.
- SDIFF: возвращает разницу множеств
- SINTER: возвращает пересечение множеств
- SUNION: возвращает объединение множеств

#+begin_src go
func main() {
	key := "string:set"
	cache.RedisCache.SAdd(key, "phone")
	err2 := cache.RedisCache.SAdd(key, "hahh").Err()
	if err2 != nil {
		fmt.Println(err2)
		return
	}
	// Get all hash objects
	all, _ := cache.SCard(key)
	fmt.Println(all)
	members, err2 := cache.SMembers(key)
	fmt.Println(members)
}
#+end_src

Как Redis хранит установленные типы данных?
- Наборы реализованы как неупорядоченная коллекция уникальных элементов.
- Redis использует оптимизированную структуру данных, чтобы гарантировать уникальность элементов в наборе.
- Операции с наборами, такие как объединение, пересечение и разность, являются эффективными.

* Упорядоченное множество (Sorted set)
