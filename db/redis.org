#+title: Redis

* Установка и запуск из docker
#+begin_src shell
# установка из образа
docker pull redis

# запуск
docker run --name some-redis -p 6379:6379 -d redis

# подключение к командной строке redis
docker network create some-network
docker run -it --network some-network --rm redis redis-cli -h some-redis
#+end_src

* Что такое Redis
=Redis= — это in-memory noSQL СУБД с открытым исходным кодом класса key-value.
Может применяться для решения самых разных задач:
+ =Кэширование= — самая частая задача, которую решают при помощи этой СУБД.
+ =Распределенная блокировка= (distributed lock). Применяется, если нужно разграничить доступ из нескольких распределенных сервисов к общему изменяемому ресурсу.
+ =Управление сессиями=. Redis можно использовать как централизованное хранилище сессий. С его помощью можно задавать время жизни сессии и вообще очень гибко управлять другими метаданными в рамках сессии.
+ =Ограничение нагрузки на определенный сервис= (Rate Limiter). Чаще всего речь идет о количестве API-вызовов в единицу времени.

=Redis= — это большая распределенная hash-таблица, где в качестве ключа используется произвольная строка, а в качестве значения — одна из поддерживаемых структур данных (строки, списки, хеш-таблицы, set, отсортированные set и т.д.).

Характеристики:
+ Персистентность: есть два режима хранения — RDB (Redis database - периодически сохраняет снэпшот всего dataset. Для этого выполняется fork основного процесса и запускается процедура записи снэпшота — BGSAVE) и AOF (append only file - реализует журнал операций, где все новые операции просто дописываются в конец файла).
+ Поддержка отказоустойчивости в различных топологиях на все случаи жизни и под любые задачи.
+ Информационная безопасность: контроль доступа и шифрование данных.
+ Configuration management и мониторинг.

Redis поддерживает различные топологии развёртывания:
+ =Один узел= или stand-alone. Самая простая топология. Имеет право на существование, но исключительно для сред разработки и тестирования, поскольку не является отказоустойчивой.
+ =Master-Replica= (Secondary). В такой топологии между мастером и репликой происходит постоянная асинхронная репликация. Для принудительной синхронизации, то есть для перехода на синхронный режим, в Redis есть специальная команда WAIT.
+ =Sentinel=. Эта топология развёртывания широко применялась на ранних версиях Redis, до поддержки полноценного кластера. Она состоит из отдельных специальных узлов, которые мониторят работу основных узлов Redis, отслеживают сбои Master и запускают процесс восстановления. Работает поверх топологии Master-Replica.
+ =Полноценный кластер=, который состоит из набора мастер-узлов и набора реплик (secondary-узлы). Для репликации используется протокол Gossip: распространение информации в нем идет способом, похожим на эпидемию — каждый узел передает информацию известным ему «соседям». Клиенты могут работать как с мастером, так и с репликой, но с реплики идет только чтение.

* Простой пример
Сначала нужно установить коннектор и запустить redis
#+begin_src shell
go get github.com/redis/go-redis/v9
docker run --name redis-test-instance -p 6379:6379 -d redis
#+end_src

Потом создаём проект
#+begin_src go
package main

import (
	"context"
	"fmt"

	"github.com/redis/go-redis/v9"
)

func main() {
	fmt.Println("hello redis world")

	client := redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "",
		DB:       0,
	})

	{
		pong, err := client.Ping(context.Background()).Result()
		fmt.Println(pong, err)
	}

	err := client.Set(context.Background(), "some", "value", 0).Err()
	if err != nil {
		panic(err)
	}

	val, err := client.Get(context.Background(), "some").Result()
	if err != nil {
		panic(err)
	}
	fmt.Println(val)
}
#+end_src

* Transaction pipelines
Позволяет клиенту Redis отправлять несколько запросов на сервер, не дожидаясь ответов и читая их все сразу.
#+begin_src go
pipe := db.Client.TxPipeline()
pipe.Set(Ctx, "language", "golang")
pipe.Set(Ctx, "year", 2009)
results, err := pipe.Exec()
#+end_src

* TODOS
https://habr.com/ru/articles/860060/
types
https://habr.com/ru/articles/204354/
https://betterstack.com/community/guides/scaling-go/redis-caching-golang/#step-7-deleting-data-from-the-cache
https://www.alexedwards.net/blog/working-with-redis
https://programmersought.com/article/881110946393/
https://www.geeksforgeeks.org/complete-guide-on-redis-data-types-with-commands-and-storage/#6-streams-in-redis
https://habr.com/ru/companies/skbkontur/articles/836944/
