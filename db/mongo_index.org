* Создание индекса
#+begin_src js
/// индекс по одному полю
> db.users.createIndex({"username" : 1})
/// составной индекс
> db.users.createIndex({"age" : 1, "username" : 1})
#+end_src

* Удаление индекса
#+begin_src js
> db.people.dropIndex("x_1_y_1")
#+end_src

* Рекомендации
1. Нужно рассмотреть селективность индекса. Нас интересует, в какой степени для данного шаблона запроса индекс будет минимизировать количество отсканированных записей.
#+begin_src js
> db.students.find({student_id:{$gt:500000}, class_id:54})
... .sort({student_id:1})
... .explain("executionStats")
#+end_src
=explain("executionStats")= - показывает план запроса, в нём нас интересует =totalKeysExamined= - число опрешенных строк и =executionTimeMillis= - время выполнения.
1. ключи для фильтров равенства должны появляться первыми;
2. ключи, используемые для сортировки, должны появляться перед многозначными полями;
3. ключи для многозначных фильтров должны появляться последними.

* Как операторы с символом $ используют индексы
** Неэффективные операторы
- В общем, отрицание неэффективно. Запросы с оператором =$ne= могут использовать индекс, но делают они это не очень хорошо. Они должны просматривать все записи индекса, кроме той, которая указана =$ne=, поэтому в основном им приходится сканировать весь индекс.
- Оператор =$not= иногда может использовать индекс, но часто не знает, как. Он может инвертировать базовые диапазоны ({"ключ" : {"$lt" : 7}} превращается в {"ключ" : {"$gte" : 7}}) и регулярные выражения. Тем не менее большинство других запросов с =$not= вернутся к сканированию таблицы.
- Оператор =$nin= всегда использует сканирование таблицы.

** Оператор $or
если вы создадите один индекс {"x": 1} и еще один индекс {"y": 1}, а затем выполните запрос для {"x": 123, "y": 456}, MongoDB будет использовать один из созданных вами индексов, но не оба.
Единственное исключение из этого правила – оператор =$or=.
=$or=  может использовать по одному индексу на каждый оператор, поскольку он выполняет два запроса, а затем объединяет результаты.

* Индексирование вложенных документов
Индексы можно создавать для ключей во вложенных документах так же, как их создают для обычных ключей
#+begin_src js
{
    "username": "sid",
    "loc": {
        "ip": "1.2.3.4",
        "city": "Springfield",
        "state": "NY"
    }
}
...
> db.users.createIndex({"loc.city" : 1})
#+end_src
индексирование самого вложенного документа ("loc") ведет себя совершенно иначе, чем индексирование поля этого документа ("loc.city").
Индексирование вложенного документа целиком поможет только запросам, которые запрашивают весь вложенный документ.

* Индексирование массивов
В ходе индексирования массива для каждого элемента массива создается индексная запись, поэтому, если у поста 20 комментариев, он будет иметь 20 индексных записей. Это делает индексы массива более затратными, по сравнению с индексами, имеющими одно значение: при одной вставке, обновлении или удалении может потребоваться обновление каждой записи массива.
=Нельзя= проиндексировать весь массив как единую сущность: при индексировании поля массива индексируется каждый элемент массива, а не сам массив.

* Типы индексов
** Уникальные
Уникальные индексы гарантируют, что каждое значение будет отображаться в индексе не более одного раза.
#+begin_src js
> db.users.createIndex({"firstname": 1},
... {"unique": true,"partialFilterExpression": {"firstname": {$exists: true } } } )
#+end_src
** Частичные индексы
Если у вас есть поле, которое может или не может существовать, но должно быть уникальным, когда оно существует, можно сочетать параметры =unique= и =partial=.
#+begin_src js
> db.users.ensureIndex({"email" : 1}, {"unique" : true, "partialFilterExpression" :
... { email: { $exists: true } }})
#+end_src
Если мы создадим частичный индекс по полю, которое может не существовать, то поиск (find), который использует этот индекс, не вернёт документы без индексного поля.
Можно использовать метод =hint=, чтобы заставить его выполнить сканирование таблицы, если вам нужны документы с пропущенными полями.

** Индексы для полнотекстового поиска
Текстовым индексам требуется некое количество ключей, пропорциональных словам в индексируемых полях. Как следствие при создании текстового индекса может потребляться большое количество системных ресурсов.
В результате приведенного ниже вызова метода =createIndex= будет создан индекс на основе термов в полях =title= и =body=:
#+begin_src js
> db.articles.createIndex({"title": "text", "body" : "text"})
#+end_src
По умолчанию каждому полю уделяется одинаковое внимание в текстовом индексе. Можно контролировать относительную важность, которую MongoDB придает каждому полю, указав веса:
#+begin_src js
> db.articles.createIndex({"title": "text",
                            "body": "text"
                          },
                          {
                              "weights": {
                                  "title": 3,
                                  "body": 2
                              }
                           })
#+end_src
Вы можете создать полнотекстовый индекс для всех строковых полей в документе, создав индекс =$**= – он не только ин-
дексирует все строковые поля верхнего уровня, но также ищет во вложенных документах и массивах строковые поля:
#+begin_src js
> db.articles.createIndex({"$**" : "text"})
#+end_src

Используйте оператор запроса =$text= для выполнения текстового поиска в коллекции с текстовым индексом. Оператор =$text= будет токенизировать строку поиска, используя пробелы и большинство знаков препинания в качестве разделителей, и логический оператор «ИЛИ» для всех таких токенов в строке поиска.
#+begin_src js
> db.articles.find({"$text": {"$search": "impact crater lunar"}},
                   {title: 1}
                  ).limit(10)
#+end_src
Можно искать точные фразы, заключив их в двойные кавычки.
#+begin_src js
> db.articles.find({$text: {$search: "\"impact crater\" lunar"}},
                   {title: 1}
                  ).limit(10)
#+end_src
Показатель релевантности хранится в поле метаданных с именем =textScore=.
#+begin_src js
> db.articles.find({$text: {$search: "\"impact crater\" lunar"}},
                   {title: 1, score: {$meta: "textScore"}}
                  ).sort({score: {$meta: "textScore"}}).limit(10)
#+end_src
