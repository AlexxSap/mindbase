* Создание индекса
#+begin_src js
/// индекс по одному полю
> db.users.createIndex({"username" : 1})
/// составной индекс
> db.users.createIndex({"age" : 1, "username" : 1})
#+end_src

* Рекомендации
1. Нужно рассмотреть селективность индекса. Нас интересует, в какой степени для данного шаблона запроса индекс будет минимизировать количество отсканированных записей.
#+begin_src js
> db.students.find({student_id:{$gt:500000}, class_id:54})
... .sort({student_id:1})
... .explain("executionStats")
#+end_src
=explain("executionStats")= - показывает план запроса, в нём нас интересует =totalKeysExamined= - число опрешенных строк и =executionTimeMillis= - время выполнения.
1. ключи для фильтров равенства должны появляться первыми;
2. ключи, используемые для сортировки, должны появляться перед многозначными полями;
3. ключи для многозначных фильтров должны появляться последними.

* Как операторы с символом $ используют индексы
** Неэффективные операторы
- В общем, отрицание неэффективно. Запросы с оператором =$ne= могут использовать индекс, но делают они это не очень хорошо. Они должны просматривать все записи индекса, кроме той, которая указана =$ne=, поэтому в основном им приходится сканировать весь индекс.
- Оператор =$not= иногда может использовать индекс, но часто не знает, как. Он может инвертировать базовые диапазоны ({"ключ" : {"$lt" : 7}} превращается в {"ключ" : {"$gte" : 7}}) и регулярные выражения. Тем не менее большинство других запросов с =$not= вернутся к сканированию таблицы.
- Оператор =$nin= всегда использует сканирование таблицы.

** Оператор $or
если вы создадите один индекс {"x": 1} и еще один индекс {"y": 1}, а затем выполните запрос для {"x": 123, "y": 456}, MongoDB будет использовать один из созданных вами индексов, но не оба.
Единственное исключение из этого правила – оператор =$or=.
=$or=  может использовать по одному индексу на каждый оператор, поскольку он выполняет два запроса, а затем объединяет результаты.

* Индексирование вложенных документов
Индексы можно создавать для ключей во вложенных документах так же, как их создают для обычных ключей
#+begin_src js
{
    "username": "sid",
    "loc": {
        "ip": "1.2.3.4",
        "city": "Springfield",
        "state": "NY"
    }
}
...
> db.users.createIndex({"loc.city" : 1})
#+end_src
индексирование самого вложенного документа ("loc") ведет себя совершенно иначе, чем индексирование поля этого документа ("loc.city").
Индексирование вложенного документа целиком поможет только запросам, которые запрашивают весь вложенный документ.

* Индексирование массивов
В ходе индексирования массива для каждого элемента массива создается индексная запись, поэтому, если у поста 20 комментариев, он будет иметь 20 индексных записей. Это делает индексы массива более затратными, по сравнению с индексами, имеющими одно значение: при одной вставке, обновлении или удалении может потребоваться обновление каждой записи массива.
=Нельзя= проиндексировать весь массив как единую сущность: при индексировании поля массива индексируется каждый элемент массива, а не сам массив.
