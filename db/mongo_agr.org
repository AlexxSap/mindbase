#+title: Фреймворк агрегации

Фреймворк агрегации представляет собой набор аналитических инструментов, которые позволяют работать с документами в одной или нескольких коллекциях.
Он основан на концепции конвейера. С помощью конвейера агрегации мы берем входные данные из коллекции MongoDB и пропускаем документы из этой коллекции через один или несколько этапов, каждый из которых выполняет свою операцию.

=Важное=
~Порядок имеет значение~
Часто нам нужно включить один и тот же тип этапа несколько раз в один конвейер. Например, нам может понадобиться выполнить начальную фильтрацию, чтобы не нужно было передавать всю коллекцию в конвейер. Позже, после дополнительной обработки, мы могли бы выполнять фильтрацию дальше, применяя другой набор критериев.

* Операции
=$match= - устанавливает условия для поиска
#+begin_src js
db.companies.aggregate([
    {$match: {founded_year: 2004}},
])
#+end_src
Это эквивалентно приведенной ниже операции с использованием метода =find=:
#+begin_src js
db.companies.find({founded_year: 2004})
#+end_src

=$project= - ограничивает вывод полей
#+begin_src js
db.companies.aggregate([
    {$match: {founded_year: 2004}},
    {$project: {
        _id: 0,
        name: 1,
        ipo: "$ipo.pub_year", /// вложенное поле
        founded_year: 1
        }
    }
])
#+end_src
В этом примере у нас есть конвейер, у которого два этапа: этап =$match= для фильтрации и этап =$project=, с помощью которого мы ограничиваем вывод только двумя полями на документ.

=$unwind= - это позволяет нам производить вывод таким образом, что для каждого элемента в указанном поле массива имеется один выходной документ.

=$limit= - ограничивает количество результатов
#+begin_src js
db.companies.aggregate([
    {$match: {founded_year: 2004 } },
    {$limit: 5},
    {$project: {
        _id: 0,
        name: 1}
        }
    ])
#+end_src
Если бы мы сначала запустили этап =project=, а затем этап =limit=, как в следующем запросе, то получили бы точно такие же результаты, но нам пришлось бы пропустить через этап =project= сотни документов, прежде чем окончательно ограничить результаты пятью вариантами.

=$skip= - пропуск результатов
#+begin_src js
db.companies.aggregate([
    {$match: {founded_year: 2004 } },
    {$sort: {name: 1 } },
    {$skip: 10},
    {$limit: 5},
    {$project: {
        _id: 0,
        name: 1}
        },
    ])
#+end_src

* Выражения
Фреймворк агрегации поддерживает множество различных классов выражений:
- =логические= выражения позволяют нам использовать выражения И, ИЛИ и НЕ
- выражения =множеств= дают нам возможность работать с массивами в качестве множеств
- выражения =сравнения= позволяют нам выражать множество различных типов фильтров диапазонов
- =арифметические= выражения
- =строковые= выражения
- =выражения= массивов предоставляют множество возможностей для манипулирования массивами
- выражения =переменных=
- =аккумуляторы= предоставляют возможность расчета сумм, описательной статистики и многих других типов значений

* Выражения массивов
=$filter= - выражение фильтра выбирает подмножество элементов в массиве на основе критериев фильтра.
#+begin_src js
db.companies.aggregate([
    { $match: { "funding_rounds.investments.financial_org.permalink": "greylock" } },
    { $project: {
        _id: 0,
        name: 1,
        founded_year: 1,
        rounds: { $filter: {
            input: "$funding_rounds", /// поле-массив
            as: "round", /// псевдоним этого поля
            cond: { $gte: [ /// условие
                "$$round.raised_amount",
                100000000 ]
                }
            }
        }
    }
    },
    { $match: { "rounds.investments.financial_org.permalink": "greylock" } },
]).pretty()
#+end_src

=$arrayElemAt= - позволяет выбрать элемент в определенной ячейке массива
#+begin_src js
    { $project: {
        ...
        first_round: { $arrayElemAt: [ "$funding_rounds", 0 ] },
        last_round: { $arrayElemAt: [ "$funding_rounds", -1 ] }
#+end_src

=$slice= - Он позволяет возвращать не один, а несколько элементов из массива в последовательности, начиная с определенного индекса
#+begin_src js
    { $project: {
        ...
early_rounds: { $slice: [ "$funding_rounds", 1, 3 ] }
#+end_src

=$size= - определение размера массива
#+begin_src js
{ $project: {
    ...
    total_rounds: { $size: "$funding_rounds" }
#+end_src

* Группировка
#+begin_src js
db.companies.aggregate([
    { $group: {
        _id: { founded_year: "$founded_year" },
        average_number_of_employees: { $avg: "$number_of_employees" }
    } },
    { $sort: { average_number_of_employees: -1 } }
])
#+end_src
Основой этапа =$group= является поле "=_id=", которое мы указываем как часть документа. Это значение самого оператора =$group=, использующего очень строгую интерпретацию.

* Запись результатов конвейера агрегации в коллекцию
=$out= имеет некоторые ограничения: он может вести запись =только в одну= и ту же базу данных, он =перезаписывает= любую существующую коллекцию, если она есть, и не может вести запись в разделенную коллекцию.

=$merge= может вести запись в =любую= базу данных и коллекцию, независимо от того, разделена она или нет, а также может включать результаты (вставка новых документов, слияние с существующими документами, сбой операции, сохранение существующих документов или обработка всех документов с пользовательским обновлением) при работе с существующей коллекцией.
Но реальным преимуществом использования =$merge= является тот факт, что он может создавать материализованные представления по требованию, где содержимое выходной коллекции постепенно обновляется при запуске конвейера.
