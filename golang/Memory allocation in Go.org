#+title: Memory Allocation In Go

https://nghiant3223.github.io/2025/06/03/memory_allocation_in_go.html

Go использует собственную, достаточно сложную модель аллокации памяти, которая сильно отличается от традиционного malloc. Вместо прямой работы с кучей Go оперирует несколькими уровнями:
- =Arena= - основной блок памяти в 64 МБ, который Go выделяет у ОС.
- =Page= - каждая арена делится на страницы по 8 КБ.
- =Span= - набор страниц, который используется для аллокаций объектов одного размера.
- =Size class= - категории размеров объектов (от tiny до large), каждая из которых имеет свой способ обработки.

Память также делится на:
- =scan= - объекты с указателями, которые должен обходить GC,
- =noscan= - объекты без указателей, GC может их игнорировать.

Аллокация объектов:
- =Tiny-объекты= (менее 16 байт) могут группироваться в один слот для ускорения.
- =Small-объекты= (до 32 КБ) выделяются из span’ов в соответствии с size class.
- =Large-объекты= (более 32 КБ) выделяются напрямую из кучи (heap).

=Escape analysis=
Go-компилятор анализирует, выходит ли переменная за пределы функции:
- если нет → объект попадает на стек,
- если да → объект уходит в кучу.
Это решает судьбу каждой переменной и напрямую влияет на работу GC.

=Стек горутин=
- Каждая горутина стартует со стека в 2 КБ.
- Стек растёт динамически (copy & grow) и может сжиматься.
- При глубокой рекурсии или сложных вычислениях рост стека может быть дорогим, так как требует копирования всех данных.

=Практические советы=
1. Избегайте лишних =tiny= / =small= аллокаций в горячих функциях - каждая мелочь создаёт нагрузку на GC.
2. Переиспользуйте срезы и буферы (`row[:0]`, sync.Pool) для минимизации мусора.
3. Объединяйте переменные в структуры, если они живут одинаковое время, чтобы уменьшить число malloc’ов.
4. Следите за размером объектов, чтобы они не перескакивали из small в large — это увеличивает расходы.
5. Профилируйте =escape analysis= (`go build -gcflags="-m"`) - он покажет, какие переменные уходят в кучу, а какие остаются на стеке.
6. Следите за ростом стека в рекурсивных функциях - копирование может быть дорогим.

Контроль над аллокацией в Go - это контроль над работой GC. Если понимать, как именно Go управляет памятью, можно проектировать код так, чтобы минимизировать аллокации, упростить жизнь GC и получить значительный прирост производительности.
