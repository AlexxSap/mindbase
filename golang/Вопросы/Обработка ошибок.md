Go обрабатывает [ошибки как значения](https://blog.golang.org/errors-are-values). Хотя в стандартной библиотеке была минимальная поддержка ошибок: лишь функции `errors.New` и `fmt.Errorf`, которые генерируют ошибку, содержащую только сообщение — встроенный интерфейс позволяет Go-программистам добавлять любую информацию. Нужен лишь тип, реализующий метод `Error`:  
  
```go
type QueryError struct {    
	Query string    
	Err   error
}
func (e *QueryError) Error() string { 
	return e.Query + ": " + e.Err.Error() 
}
```

#### Исследование ошибок

Ошибки в Go являются значениями. Программы принимают решения на основе этих значений разными способами. Чаще всего ошибка сравнивается с nil, чтобы понять, не было ли сбоя операции.  
  
```go
if err != nil {    // something went wrong}
```

  
Иногда мы сравниваем ошибку, чтобы узнать _контрольное_ значение и понять, не возникла ли конкретная ошибка.

Зачастую функция передаёт ошибку вверх по стеку вызовов, добавляя к ней информацию, например, короткое описание того, что происходило в момент возникновения ошибки. Это сделать просто, достаточно сконструировать новую ошибку, включающую в себя текст из предыдущей ошибки:  
  
```go
if err != nil {    
	return fmt.Errorf("decompress %v: %v", name, err)
}
```

При создании новой ошибки с помощью `fmt.Errorf` мы выбрасываем из исходной ошибки всё, за исключением текста.

#### Метод Unwrap

Самым важным является соглашение, а не изменение: ошибка, содержащая другую ошибку, может реализовать метод `Unwrap`, который возвращает исходную ошибку. Если `e1.Unwrap()` возвращает `e2`, то мы говорим, что `e1` упаковывает `e2` и можно распаковать `e1` для получения `e2`.

Согласно этому соглашению, можно дать описанный выше тип `QueryError` методу `Unwrap`, который возвращает содержащуюся в нём ошибку:  
  
```go
func (e *QueryError) Unwrap() error { 
	return e.Err 
}
```

Результат распаковки ошибки тоже может содержать метод `Unwrap`. Последовательность ошибок, полученных с помощью повторяющихся распаковок, мы называем _цепочкой ошибок_.

#### Исследование ошибок с помощью Is и As

Пакет `errors` содержит две функции для исследования ошибок: `Is` и `As`.  
  
Функция `errors.Is` сравнивает ошибку со значением.

```go
// Similar to:
//   if err == ErrNotFound { … }
if errors.Is(err, ErrNotFound) {    
	// something wasn't found
}
```

Функция `As` проверяет, относится ли ошибка к конкретному типу.  
```go
// Similar to:
//   if e, ok := err.(*QueryError); ok { … }

var e *QueryError
if errors.As(err, &e) {    
	// err is a *QueryError, and e is set to the error's value
}
```

В простейшем случае функция `errors.Is` ведёт себя как сравнение с контрольной ошибкой, а функция `errors.As` ведёт себя как утверждение типа. Однако работая с упакованными ошибками, эти функции оценивают все ошибки в цепочке.

Пакет `errors` также содержит новую функцию `Unwrap`, которая возвращает результат вызова метода `Unwrap` ошибки, или возвращает nil, если у ошибки нет метода `Unwrap`. Обычно лучше использовать `errors.Is` или `errors.As`, поскольку они позволяют исследовать всю цепочку одним вызовом.

#### Упаковка ошибок с помощью %w
  
Как я упоминал, нормальной практикой является использование функции `fmt.Errorf` для добавления к ошибке дополнительной информации.  
```go
if err != nil {    
	return fmt.Errorf("decompress %v: %v", name, err)
}
```

В Go 1.13 функция `fmt.Errorf` поддерживает новая команда `%w`. Если она есть, то ошибка, возвращаемая `fmt.Errorf`, будет содержать метод `Unwrap`, возвращающий аргумент `%w`, который должен быть ошибкой. Во всех остальных случаях `%w` идентична `%v`.  
  ```go
if err != nil {    
	// Return an error which unwraps to err.    
	return fmt.Errorf("decompress %v: %w", name, err)}
```

Упаковка ошибки с помощью `%w` делает её доступной для `errors.Is` и `errors.As`:  
```go
err := fmt.Errorf("access denied: %w", ErrPermission)
...
if errors.Is(err, ErrPermission) 
...
```