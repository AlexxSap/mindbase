#+title: Подводные Камни Работы С Пакетом Time

Пакет time в языке Go — мощный инструмент, но с рядом нюансов, которые важно понимать, особенно при разработке кросс-платформенного кода, тестировании производительности и работе с часовыми поясами.
В статье https://dev.to/rezmoss/important-considerations-when-using-gos-time-package-910-3aim автор выделяет ключевые моменты, на которые стоит обратить внимание каждому Go-разработчику.

Работа со временем — это всегда зона риска: вы можете не заметить, как из-за смены часового пояса или перехода на летнее время ваша система начнёт вести себя непредсказуемо. В Go это особенно критично, поскольку язык делает ставку на простоту, но предоставляет тонкие механизмы управления временем.

Перейдём к основным идеям статьи:
- Монотонное время в Go
  Go использует монотонные часы (monotonic time) при сравнении времён и вычислении интервалов.
  Это означает, что функции вроде =time.Since(start)= или =time.Until(deadline)= не зависят от текущего системного времени, что защищает от проблем при его изменении (например, если системное время изменилось вручную или произошло переключение на летнее/зимнее).
  Однако есть нюанс: поддержка монотонного времени зависит от операционной системы. Например, на Windows поведение может отличаться от Linux. Кроме того, некоторые функции =time.Time=, особенно при сериализации (например, =MarshalJSON=), не сохраняют информацию о монотонности. Поэтому нельзя полагаться на =time.Since()= между разными экземплярами времени, сериализованными и десериализованными между процессами или машинами.

- Точность ожиданий
  Функции вроде =time.Sleep= или таймеры =time.After= не гарантируют точности в миллисекундах или тем более микросекундах. Если вам важно очень точное ожидание — например, в измерениях производительности — лучше использовать активное ожидание с проверкой времени, хоть это и более затратно для CPU:
#+begin_src go
deadline := time.Now().Add(1 * time.Millisecond)
for time.Now().Before(deadline) {
    // активный busy-loop
}
#+end_src
Такой способ может быть полезен в тестах, где нужна высокая точность, но для продакшена не рекомендуется из-за нагрузки.

- Бенчмаркинг и измерения
  Многие разработчики используют =time.Now()= для измерения производительности кода. ~Это ошибка~. Вместо этого используйте пакет =testing= и его возможности =Benchmark=:
#+begin_src go
func BenchmarkMyFunc(b *testing.B) {
    for i := 0; i < b.N; i++ {
        MyFunc()
    }
}
#+end_src
Go сам подберёт количество итераций и обеспечит надёжные измерения с учётом шумов и сборщика мусора.

- Часовые пояса
  В Go объект =time.Time= всегда содержит информацию о часовом поясе. ~Это важно!~
  Не путайте:
  - UTC() — время в UTC
  - Local() — локальное системное время
  - In(loc *time.Location) — преобразование времени в конкретную временную зону

Вы можете работать с временными зонами через файл =zoneinfo=, но будьте внимательны — не все контейнерные образы или минималистичные ОС содержат актуальные данные о временных зонах, и это может привести к неожиданным ошибкам.

- Сравнение времён
  При сравнении времён важно, чтобы они были приведены к одной временной зоне.
  Даже если два объекта =time.Time= представляют одинаковую точку во времени, но один — в UTC, а другой — в Local(), t1.Equal(t2) может вернуть false. Для сравнения используйте:
#+begin_src go
t1.UTC().Equal(t2.UTC())
#+end_src

Или используйте =Sub()= и =Before/After= — они учитывают монотонную часть и обычно безопаснее.
