#+title: Timeouts в Go: Управление длительными задачами

В разработке на Go часто требуется ограничивать время выполнения задач, чтобы избежать зависаний или ненужной траты ресурсов. Таймауты помогают контролировать выполнение операций, обеспечивая стабильность и отзывчивость приложений.

=Что такое таймаут?=
Таймаут позволяет задать время, после которого задача будет прервана, если она не завершилась. Это особенно полезно в случае сетевых запросов, работы с базами данных или сложных вычислений, которые могут зависнуть.

=Как реализовать таймауты в Go?=
Go предлагает несколько удобных инструментов для работы с таймаутами. Вот несколько примеров:

1. =Контексты с таймаутом=
Контекст позволяет задавать ограничение по времени, которое автоматически завершит задачу при превышении лимита.
#+begin_src go
ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
defer cancel()

result := make(chan string)

go func() {
    time.Sleep(3 * time.Second) // Долгая операция
    result <- "Задача завершена"
}()

select {
case res := <-result:
    fmt.Println("Результат:", res)
case <-ctx.Done():
    fmt.Println("Таймаут:", ctx.Err())
}
#+end_src
Зачем использовать?
Это гибкий способ контролировать выполнение задач с возможностью передать контекст в функции.

2. =Таймауты с time.After=
Функция ~time.After~ позволяет просто установить ограничение времени для выполнения задачи.
#+begin_src go
done := make(chan string)

go func() {
    time.Sleep(3 * time.Second) // Долгая операция
    done <- "Успешно выполнено"
}()

select {
case res := <-done:
    fmt.Println(res)
case <-time.After(2 * time.Second):
    fmt.Println("Таймаут! Слишком долго")
}
#+end_src
Когда использовать?
Когда нужен быстрый и простой способ контролировать длительные операции.

3. =HTTP-запросы с таймаутом=
Для работы с сетевыми запросами Go предоставляет возможность задавать таймаут на уровне HTTP-клиента.
#+begin_src go
client := http.Client{
    Timeout: 2 * time.Second,
}

_, err := client.Get("https://httpstat.us/200?sleep=3000")
if err != nil {
    fmt.Println("Ошибка запроса:", err)
} else {
    fmt.Println("Запрос выполнен успешно!")
}
#+end_src
Преимущество:
Контроль времени выполнения сетевых операций без дополнительных инструментов.

=Почему это важно?=
Избежание зависаний: таймауты предотвращают блокировку программы.
Оптимизация ресурсов: долгие задачи прерываются, освобождая память и процессор.
Улучшение UX: пользователи быстрее получают обратную связь, даже если операция не удалась.
