#+title: Сигналы Ос

Наверняка вы не раз о них слышали. И, как обычно, выглядит оно сначала страшновато, а по факту это максимально простой и понятный механизм. Давайте разбираться.

=Сигналы= - это просто способ сообщить запущенной программе, что произошло какое-то событие. Говоря более умными словами, это механизм асинхронного оповещения процессов.

Как это работает:
1. Процесс А хочет что-то сообщить процессу Б
2. А отправляет определенный сигнал через системный вызов kill() (https://ru.wikipedia.org/wiki/Kill)
3. Ядро прерывает выполнение Б и вызывает соответствующий обработчик сигнала
4. После обработки, Б продолжает работу с того места, где был прерван

Название системного вызова `kill()` с непривычки наверняка вызывает недумение, да? Название может вводить в заблуждение, но эта команда занимается именно отправкой любого сигнала, не обязательно SIGKILL или SIGTERM

Чаще всего встречаются вот такие сигналы:
- SIGTERM - "вежливая" просьба завершиться
- SIGKILL - принудительное завершение ("убить процесс")
- SIGINT - прерывание с клавиатуры (Ctrl+C)
- SIGSEGV - обращение к недопустимой области памяти
- SIGUSR1 / SIGUSR2 - пользовательские сигналы для своих нужд

Ну и, конечно, наш любимый SIGURG — если вы о нём не знаете, то после ролика про планировщик точно будете знать (я слышал, на днях должен уже выйти).

Кстати, сигналы SIGKILL и SIGSTOP (https://ru.wikipedia.org/wiki/SIGSTOP) немного особенные — их нельзя перехватить / игнорировать, учитывайте это.

В Go с сигналами удобно работать через os/signal:
#+begin_src go
sigChan := make(chan os.Signal, 1)
signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

// Ждем сигнал
sig := <-sigChan
fmt.Printf("Получен сигнал: %v\n", sig)
#+end_src

Где они могут вам встретиться:
- Graceful shutdown - корректное завершение по SIGTERM
- Reload конфигов по SIGUSR1
- Ротация логов по SIGUSR2

Кстати, насколько я знаю, в Windows механизм сигналов сильно ограничен. Но в этом я разбираюсь ещё хуже.

Кстати, на собседованиях любят спрашивать про разницу между SIGTERM и SIGKILL. Так вот, первый позволяет процессу корректно завершиться, второй убивает его принудительно.

————
Полезные материалы:
- Signal(7) (https://man7.org/linux/man-pages/man7/signal.7.html) - man page
- Как программы общаются между собой (https://habr.com/ru/companies/ruvds/articles/715008/)
- Практика работы с сигналами (https://habr.com/ru/articles/141206/)
