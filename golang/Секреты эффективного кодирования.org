#+title: Секреты Эффективного Кодирования

* Утечки памяти из-за бесконтрольного роста кеша
Если вы накапливаете элементы в срезе без очистки старых, буфер постепенно «раздувается» и может довести сервис до OOM (out of memory — «недостаток памяти», то есть аварийное завершение программы из-за исчерпания доступного объёма оперативной памяти).
#+begin_src go
var cache []Item
// Каждый вызов добавляет новые данные, но старые не удаляются
func AddToCache(item Item) {
    cache = append(cache, item)
}
#+end_src

=Что делать=
периодически обрезайте срез или используйте sync.Pool для переиспользования объектов, например:
#+begin_src go
buf := buf[:0]   // Сбрасываем длину, но сохраняем ёмкость
pool := sync.Pool{ New: func() interface{} { return make([]byte, 0, 1024) } }
#+end_src

* Переиспользование одного context.Context в цикле
Повторное обогащение базового контекста копирует в него всю историю и не позволяет сборщику мусора освободить старые данные:
#+begin_src go
// Антипаттерн: обогащаем один и тот же контекст снова и снова
ctx := context.Background()
for payload := range receive {
    ctx = context.WithValue(ctx, "key", payload.ID)
    processTask(ctx, payload)
}
#+end_src

=Что делать=
создавайте новый контекст поверх неизменного «базового»:
#+begin_src go
// Идиоматично: сброс ссылок на старые данные
go func(bgctx context.Context) {
    for payload := range receive {
        msgctx := contexts.NewHubContext(bgctx)
        processTask(msgctx, payload)
    }
}(context.Background())
#+end_src

* Забытый time.Ticker и незакрытые каналы.
Таймеры и каналы запускают внутренние горутины: если вы не вызовете ticker.Stop() или не закроете канал, горутины всё время будут «жить» и пожирать ресурсы, а ваши воркеры заблокируются:
#+begin_src go
ticker := time.NewTicker(time.Minute)
// ❌ Ошибка: ticker объявлен, но Stop не вызван
go func() {
    for now := range ticker.C {
        fmt.Println("tick at", now)
    }
}()
#+end_src

Правильный подход:
#+begin_src go
ticker := time.NewTicker(time.Minute)
defer ticker.Stop()  // Гарантированно освобождаем ресурсы
go func() {
    for {
        select {
        case now := <-ticker.C:
            fmt.Println("tick at", now)
        case <-ctx.Done():
            return
        }
    }
}()
#+end_src

* Что такое идиоматичный Go и как правильно оформлять код
Чтобы писать идиоматичный код, достаточно следовать трём правилам. Разберём их.

1. Разбейте проект на маленькие пакеты по зонам ответственности, чтобы сразу было понятно, где что живёт:
   - api — только HTTP/gRPC-хендлеры;
   - services — бизнес-логика (авторизация, расчёты, валидация);
   - storages — код работы с базами и хранилищами (Postgres, Redis, S3);
   - clients — внешние API-клиенты;
   - cmd/<app> — main.go для каждого сервиса.

2. Проверяйте ошибки сразу после вызова: if err != nil { … }, — не пряча их в панике или цепочках обёрток.
3. Автоформатируйте с помощью go fmt и goimports, чтобы пробелы и отступы не отвлекали от сути. Коммиты будут отличаться только реальным кодом, а не пробелами.

* Как работать с конкурентностью и избежать лишнего стресса
Для надёжной и понятной конкурентной работы в Go объединяйте горутины в пул воркеров, где число воркеров задаётся как GOMAXPROCS() только для CPU-задач и может быть больше для I/O-операций.
Используйте буферизированный канал с ёмкостью примерно в 2–4 раза больше числа воркеров, чтобы сгладить пики нагрузки.
Всегда передавайте всем горутинам один и тот же context.Context и при вызове cancel() завершайте их через select с веткой <-ctx.Done(), а каналы закрывайте только после того, как все данные отправлены.

* Как управлять памятью и контролировать сборку мусора
Go‑рантайм сам отвечает за сбор мусора, но от разработчика зависит, сколько лишних аллокаций будет создано.
С помощью net/http/pprof и go tool trace находите «горячие» точки по CPU и памяти, а go test -bench -cpuprofile -memprofile + benchstat позволят сравнить версии кода и покажут эффект оптимизаций.
Для переиспользования объектов используйте sync.Pool: он возвращает готовые структуры вместо новых аллокаций. Эффективен для короткоживущих объектов с частым доступом.

* Как использовать профайлинг и точечно оптимизировать код
В Go профайлинг встроен «из коробки»: достаточно подключить пакет net/http/pprof, чтобы получить HTTP-эндпоинты для CPU- и heap-профилей, а командой go tool trace разобрать детальный трейс работы горутин и системных вызовов.
Дополнительно бенчмарки запускаются через go test -bench . -cpuprofile cpu.prof -memprofile mem.prof, а утилита benchstat old.txt new.txt из пакета golang.org/x/perf покажет, насколько изменилась производительность между версиями.
В итоге сочетание pprof, go tool trace и benchstat позволяет точечно найти «горячие» места, проверить влияние правок в «тест-пробеге» и визуализировать прогресс в понятных отчётах: от flame-графов до табличного сравнения результатов.

* Как организовать тестирование и автоматизировать CI/CD
В Go модульные тесты пишут с помощью пакета testing, часто оформляя их как табличные тесты: вы задаёте список входов и ожидаемых результатов и прогоняете их в цикле.
Для проверок HTTP-хендлеров используйте net/http/httptest, а для замеров скорости — бенчмарки testing.B через go test -bench. Чтобы найти неожиданные ошибки, можно добавить fuzz-тесты командой go test -fuzz. Покрытие кода смотрят через go test -cover и визуализируют с помощью go tool cover.

* Как структурировать проект и управлять зависимостями
В Go принято держать проект в единой, но чётко организованной структуре. В корне лежат файлы go.mod и go.sum, а рядом три ключевые папки:
- cmd/ хранит точки входа — для каждого приложения или микросервиса своя папка с main.go;
- pkg/ содержит публичные библиотеки и утилиты, которые можно переиспользовать в других проектах;
- internal/ включает приватные пакеты, доступные только внутри вашего репозитория: здесь обычно лежит бизнес-логика и слой работы с базой.

* Чек-лист: что сделать, чтобы ваш Go-код был надёжным, быстрым и поддерживаемым
1. Запустить go fmt и goimports для единообразного форматирования кода и автоматического управления импортами.
2. Прогнать go vet и golangci-lint для раннего обнаружения ошибок и нарушения стиля.
3. Во всех функциях явно проверять ошибки (if err != nil { return … }) и перед использованием указателей/интерфейсов делать nil-проверку.
4. Написать табличные юнит-тесты с пакетом testing и использовать net/http/httptest для проверки HTTP-хендлеров.
5. Добавить бенчмарки с testing.B (через go test -bench), вставив b.ResetTimer() и b.ReportAllocs(), чтобы измерять ns/op, B/op и allocs/op.
6. Запустить fuzz-тесты командой go test -fuzz ./… для автоматического нахождения ошибок на случайных входных данных.
7. Оценить покрытие тестами с помощью go test -cover и визуализировать отчёт через go tool cover.
8. Подключить net/http/pprof, проанализировать трейс командой go tool trace, профилировать CPU/heap через go test -cpuprofile и -memprofile и сравнить результаты утилитой benchstat.
9. Организовать пул воркеров с числом goroutine = runtime.GOMAXPROCS(), использовать буферизированный канал (с ёмкостью в 2–4 раза больше числа  воркеров) и единый context.Context для отмены + корректно закрывать каналы.
10. Настроить CI/CD со стадиями: go fmt → go vet → golangci-lint → go test -cover -fuzz → сборка бинарников → деплой.
