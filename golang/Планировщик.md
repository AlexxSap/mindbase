Основано на
https://habr.com/ru/articles/743266/
https://habr.com/ru/articles/804145/

видос 
https://www.youtube.com/watch?v=uU0FbA3u5vI
https://www.youtube.com/watch?v=P2Tzdg8n9hw

Каждая программа, которую мы запускаем, создает процесс, и каждому процессу присваивается его начальный поток. У процесса может быть несколько потоков. Все они выполняются независимо друг от друга, и решения о планировании принимаются на уровне потока, а не на уровне процесса. Потоки могут выполняться конкурентно (на одном ядре) или параллельно (каждый из них выполняется одновременно на разных ядрах). Потоки также сохраняют свое собственное состояние, чтобы обеспечить безопасное, локальное и независимое выполнение своих инструкций.

Планировщик OS отвечает за то, чтобы ядра не простаивали, если есть потоки, которые могут выполняться. Его задача - создавать иллюзию того, что все потоки выполняются одновременно. В процессе создания этой иллюзии планировщик должен запускать потоки с более высоким приоритетом по сравнению с потоками с более низким приоритетом. Однако потоки с более низким приоритетом не должны испытывать недостаток времени выполнения. Планировщик также должен максимально минимизировать задержки планирования, принимая быстрые и разумные решения. Планировщик OS является недетерминированным. Это означает, что мы не можем предсказать, что планировщик собирается делать в тот или иной момент времени.

Горутины раcпределяются по потокам, которыми Планировщик Go управляет под капотом. Мы знаем о горутинах следующее:
- Горутины, если говорить о скорости исполнения, не обязательно быстрее чем потоки, так как они нуждаются в потоках, чтобы ими исполняться.
- Ключевое преимущество горутин — в таких нюансах как контекст свитчинг, размере занимаемой ими памяти и стоимости создания и «удаления».

![[Pasted image 20240406153821.png]]

### Типы выполняемой работы(Types Of Work):
    
- CPU-Bound. Это работа, которая никогда не создает ситуации, где поток может быть помещен в состояние ожидания. Пример: вычисление числа pi до n-й цифры является CPU-Bound работой.
        
- I/O-Bound. Это работа, которая заставляет потоки входить в состояние ожидания. Как пример, работа, которая заключается в запросе доступа к ресурсу по сети или совершении системных вызовов в операционную систему. Поток, которому необходимо получить доступ к базе данных, будет выполнять I/O-Bound работу.

### Переключения контекста (Context Switching)

Это физический акт обмена потоками на ядре. Переключение контекста происходит, когда планировщик вытягивает Executing поток из ядра и заменяет его Runnable потоком. Вытащенный поток может вернуться в состояние Runnable (если он все еще может работать) или в состояние Waiting (если он был заменен из-за запроса типа I/O-Bound). Переключение контекста считается дорогой операцией и происходит относительно медленно. Величина задержки, возникающая при переключении контекста, зависит от различных факторов. Если исходить из расчета, что машина выполняет 12 операций в наносекунду, а переключение контекста занимает ~ 1000 до ~ 1500 наносекунд, то мы теряем 12 000 операций и более.

### Планировщик M:N

Это значит, что роль планировщика Go в том, чтобы привязать M горутин к N потоков ядра, формируя модель M:N. У вас может быть как больше потоков ОС, чем ядер, так и больше горутин, чем потоков.

### PMG модель

Горутина — это самый маленький юнит исполнения в Go, работа которого похожа на легковесный поток.
Вместе с рантаймом Go, горутина представляет из себя структуру `g`. Как только она вызывается, она находит свое место в локальной очереди исполнение логического процессора P. P, в свою очередь, передает ее на исполнение потоку ОС (M).

Горутина может находиться в трех (основных) состояниях:
- **Waiting:** В этом состоянии, горутина бездействует. Например встает на паузу для операции с каналами или блокировками, либо может быть остановлена системным вызовом.
- **Runnable:** Горутина готова к тому чтобы быть исполненной, но еще не исполняется. Она ожидает своей очереди на потоке (M).
- **Running:** Горутина исполняется на потоке (M). Это будет продолжаться, пока работа не будет выполнена, или до тех пор, пока ее не прервет планировщик, либо что‑то еще ее не заблокирует.


Когда новая горутина инициируется, планировщик Go обращается к пулу горутин чтобы забрать одну, и если ни одной нет, то создает новую. Эта новая горутина добавляется в исполняемую очередь процесора (P).

#### P (Логический процессор)
_Количество P говорит нам о том, сколько горутин может исполняться конкурентно._

Вместе с планировщиком Go, когда мы говорим «процессор», мы имеем ввиду логическую сущность, а не физический процессор. Тем не менее, по умолчанию количество P устанавливается равному количеству доступных ядер на хосте, вы можете изменить это значение, используя `runtime.GOMAXPROCS(int)`.
Каждый из P содержит собственный список runnable горутин, который называется Локальная Очередь Исполнения (Local Run Queue), размер которой может составить до 256 горутин.

#### M (Поток ОС)

Обычное Go приложение может использовать до 10 000 потоков. Если вы выйдете за рамки этого лимита, есть риск того, что приложение крашится.

Если горутина находится в состоянии runnable и ей требуется поток.Что произойдет, если все потоки уже заблокированы, возможно системными вызовами или невытесняемыми операциями? В этом случае в игру вступает планировщик и создает новый поток для этой горутины.

Если вы хотите изменить лимит поток по умолчанию, можно воспользоваться функцией `runtime/debug.SetMaxThreads()` . Она позволит установить максимальное количество потоков ОС, которое сможет использовать приложение. Так же, стоит помнить о том, что потоки переиспользуются, так как создание и удаление потока — ресурсоемкие операции.


### Как работает MPG

![[Pasted image 20240406164146.png]]

1. **Инициирование горутины:** используя `go func()`, рантайм Go создает новую горутину, или использует уже существующую из пула.
2. **Позиционирование в очереди:** горутина ищет место в локальных очередях логических процессоров (P), и если они все переполнены, она помещается в глобальную очередь.
3. **Связывание с потоком:** в этом шаге поток (M) вступает в игру. Поток берет P и начинает исполнять горутины из его локальной очереди. Как только поток приступает к исполнению горутины, процессор (P), в очереди которого находилась горутина, ассоциируется с этим потоком (M) и становится недоступен для других потоков.
4. **«Заимствование работы» (work stealing):** если локальная очередь процессора (P) опустела, поток M пытается позаимствовать половину runnable горутин из локальной очереди другого процессора (P). Если ничего не нашлось, поток (M) проверяет глобальную очередь и затем Net Poller (ниже есть диаграмма процесса **work stealing).**
5. **Аллокация ресурсов:** после того как, поток M выберет горутину G, он обеспечивает ее всеми необходимыми ресурсами.


Если горутина совершает системный вызов, который займет много времени (например чтение файла), поток M будет ожидать. Но планировщик не устраивают те, кто просто сидит и ждет. Он отвязывает занятый поток M от его процессора P, и связывает другую runnable горутину из очереди P к новому или существующему свободному потоку M, который ассоциируется с этим процессором.

### GRQ, LRQ

В планировщике Go есть две разные очереди выполнения: глобальная очередь выполнения (Global Run Queue - GRQ) и локальная очередь выполнения (Local Run Queue - LRQ). Каждому P присваивается LRQ, которая управляет горутинами, назначенными для выполнения на P. Эти горутины по очереди включаются и выключаются в зависимости от контекста M, назначенного этому P.  GRQ предназначен для горутин, которые еще не были назначены для какого-либо P. Существует процесс перемещения горутин из GRQ в LRQ.
    
### Процесс заимствования (work stealing)

Когда поток M исполнил все свои задания и ему больше нечего делать, это не значит что он будет простаивать. Поток будет искать горутины в локальных очередях других логических процессоров и заберет половину их горутин. Даже если поток M забирает горутины из несвязанного с ним процессора P, он будет исполнять эти горутины используя их процессор. Таким образом, пока поток исполняет чужие горутины, он не теряет связь со своим собственным процессором.

### Network Poller

Как и планировщик Go, Network Poller — компонент рантайма Go и служит для исполнения запросов связанных с сетью, например сетевые операции I/O.

Есть 2 типа системных вызовов:

- **Системные вызовы связанные с сетью:** когда горутина выполняет сетевую операцию I/O, вместо того чтобы блокировать поток, она добавляется в network poller. Netpoller ожидает асинхронного выполнения операции, и когда дожидается — горутина снова становится runnable, и ее исполнение становится доступно для потока.
    
- **Другие системные вызовы:** если они потенциально блокирующие и не будут исполнены network poller»ом, горутина полностью займет поток ОС, этот поток будет заблокирован и рантайм Go будет исполнять остальные горутины на других свободных потоках.