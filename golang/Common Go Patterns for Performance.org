#+title: Common Go Patterns For Performance

https://goperf.dev/01-common-patterns/


* Управление памятью и эффективность

- Pooling объектов: Повторное использование объектов для снижения нагрузки на сборщик мусора и уменьшения накладных расходов на выделение памяти.​

- Предварительное выделение памяти: Заранее задавать емкость срезов и карт для предотвращения дорогостоящих операций изменения размера.​

- Выравнивание полей структур: Оптимизация расположения полей в структурах для минимизации заполнения и улучшения локальности данных.​

- Избегание упаковки интерфейсов: Предотвращение скрытых выделений памяти путем отказа от ненужных преобразований типов к интерфейсам.​


- Техники нулевого копирования: Минимизация копирования данных с использованием срезов и буферов.​

- Эффективность памяти и сборщик мусора Go: Снижение нагрузки на сборщик мусора путем минимизации использования кучи и повторного использования памяти.​

- Стековые выделения и анализ ускользания: Использование анализа ускользания для размещения значений в стеке, когда это возможно.​

* Конкурентность и синхронизация

Пулы рабочих горутин: Контроль уровня конкурентности с помощью пулов фиксированного размера для ограничения использования ресурсов.​

Атомарные операции и примитивы синхронизации: Использование атомарных операций или легковесных блокировок для управления общим состоянием.​

Ленивая инициализация: Отсрочка выполнения затратных операций до момента, когда они действительно необходимы.​

Совместное использование неизменяемых данных: Безопасное совместное использование данных между горутинами без блокировок путем обеспечения их неизменяемости.​
goperf.dev

Эффективное управление контекстом: Использование пакета context для передачи тайм-аутов и сигналов отмены между горутинами.​


* Оптимизация ввода/вывода и пропускная способность

Эффективное буферизирование: Использование буферизованных читателей/писателей для минимизации вызовов ввода/вывода.​

Группировка операций: Объединение нескольких мелких операций для уменьшения количества раунд-трипов и повышения пропускной способности.​

* Оптимизация на уровне компилятора и настройка

Использование флагов оптимизации компилятора: Применение флагов сборки, таких как -gcflags и -ldflags, для настройки производительности.​

Стековые выделения и анализ ускользания: Анализ того, какие значения переходят в кучу, чтобы помочь компилятору оптимизировать размещение памяти.​

Эти техники помогают разработчикам Go создавать более эффективные и производительные приложения, снижая задержки, улучшая использование памяти и повышая эффективность конкурентных операций.
