https://habr.com/ru/articles/742402/

## Как управлять сборщиком мусора?

Существует параметр, который позволяет управлять сборщиком мусора в Go - это переменная окружения `GOGC` или ее функциональный аналог `SetGCPercent` из пакета `runtime/debug`.

Параметр `GOGC` определяет _процент_ новой необработанной памяти кучи от живой памяти, при достижении которого будет запущена сборка мусора. Значение `GOGC` по умолчанию равно 100, что означает, что сборка мусора будет запущена, когда объем новой памяти достигнет 100% от объема живой памяти кучи.

## Вызываем GC чаще

Если мы запустим код, предварительно установив `debug.SetGCPercent(10)` на 10%, то мы увидим, что частота вызова сборщика мусора увеличится: теперь сборщик мусора будет вызываться, когда размер текущей кучи составляет 10% от размера живой кучи.

Мы видим, что установка `GOGC` в значение меньше 100% может увеличить частоту сборки мусора, что может привести к увеличенному использованию процессорного времени и снижению производительности программы.

## Вызываем GC реже

Если мы вызовем ту же программу, но с настройкой `debug.SetGCPercent(1000)` в 1000%, то получим следующий результат:

В текущем случае сборщик мусора был вызван 1 раз и выполнялся в течение 2 мс.

## Отключаем GC

Мы можем также отключить сборщик мусора, установив `GOGC=off` или используя `debug.SetGCPercent(-1)`.
## Как избежать OOM?

Начиная с версии 1.19 в Golang вводится так называемое мягкое управление памятью с помощью переменной окружения `GOMEMLIMIT` или аналогичной функции из пакета runtime/debug `SetMemoryLimit` ([здесь](https://github.com/golang/proposal/blob/master/design/48409-soft-memory-limit.md) можно прочитать некоторые интересные детали проектирования данного механизма).

Переменная окружения `GOMEMLIMIT` устанавливает _общий_ _объем памяти_, которым может пользоваться среда выполнения Go (Go runtime), например:

```
GOMEMLIMIT = 8MiB
```

Для установки значения памяти используется суффикс размерности, например MiB - это Мб.

Запустим контейнер с установленной переменной окружения `GOMEMLIMIT = 8MiB`. Для этого пропишем в docker-compose переменную окружения enviroment:

```
version: '3'
services:
 my-app:
    environment:
      GOMEMLIMIT: "8MiB"
   build:
     context: .
     dockerfile: Dockerfile
   ports:
     - 8080:8080
   deploy:
     resources:
       limits:
         memory: 10M
```

Теперь, при запуске контейнера, программа выполняется полностью без ошибки OOM.

Это происходит потому, что после включения `GOMEMLIMIT = 8MiB` сборщик мусора вызывается всякий раз, когда общая память приближается к лимиту, и поддерживает размер кучи в заданных `GOMEMLIMIT` пределах. Это приводит к более частым вызовам сборщика мусора.

Именно для решения этой проблемы был придуман механизм `GOMEMLIMIT`.

## Спираль смерти

`GOMEMLIMIT` является мощным и полезным инструментом, который также может выстрелить в ногу. Пример опасного поведения виден на предыдущем графике.

Когда размер общей памяти, вызванный ростом живой кучи или постоянными утечками горутин, приближается к `GOMEMLIMIT`, сборщик мусора начинает вызываться часто, чтобы уменьшить потребляемую память.

Из-за повторных вызовов сборщика мусора время работы приложения теоретически может неограниченно возрастать, забирая процессорное время у самого приложения. Такое поведение называется [спиралью смерти](https://github.com/golang/proposal/blob/master/design/48409-soft-memory-limit.md#death-spirals). Это может привести к полной деградации работы приложения, и такое поведение, в отличие от ошибки OOM, очень сложно отследить.

Именно поэтому механизм `GOMEMLIMIT` работает как _мягкое ограничение_.

Go не предоставляет 100% гарантий соблюдения ограничения памяти `GOMEMLIMIT`. Это позволяет избежать ситуации частого вызова сборщика мусора, так как позволяет использовать память сверх лимита.

Для этого установлен предел использования процессорного времени. В настоящее время этот предел установлен на 50% с окном CPU в `2 * GOMAXPROCS` секунды.

Также это значит в случае утечек памяти, что мы полностью не сможем избежать ошибки OOM, она просто произойдет значительно позже.

## Как применять GOGC и GOMEMLIMIT

Механизм мягкого управления памятью с помощью `GOMEMLIMIT` и изменение настроек сборщика мусора `GOGC` может защитить нас от неприятных ситуаций и улучшить эффективность работы приложения.

Приведем примеры случаев, когда использование`GOMEMLIMIT` и `GOGC` может быть полезным:

1. Приложение, запущенное в контейнере с ограниченным объемом памяти. Хорошей практикой будет настроить `GOMEMLIMIT` так, чтобы оставалось 5-10% от доступной в контейнере памяти.
    
2. При запуске библиотеки или кода, требующего значительных ресурсов. Здесь можно динамически управлять `GOMEMLIMIT` для оптимальной работы.
    
3. При запуске приложения в контейнере в качестве скрипта, где приложение выполняет определенную задачу в течение некоторого времени и затем завершается. Для повышения производительности можно отключить сборщик мусора `GOGC=off`, но установить `GOMEMLIMIT`, чтобы не превысить доступные ресурсы контейнера по памяти.
    

Существуют и случаи, когда лучше избегать использования `GOMEMLIMIT`:

1. Не устанавливайте ограничение памяти, если программа уже близка к предельному значению памяти своей среды.
    
2. Не используйте ограничение памяти при развертывании в исполнительной среде, которой вы не управляете, особенно если использование памяти вашей программой пропорционально входным данным. Например, это может быть CLI-инструмент или настольное приложение.