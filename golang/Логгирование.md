https://habr.com/ru/companies/slurm/articles/798207/
https://pkg.go.dev/log/slog

Пакет `log/slog` предоставляет три основных типа:
- `Logger`: это "фронтэнд" логгирования, который предоставляет методы уровня (`Info()` и `Error()`) для записи интересующих событий.
- `Record`: представление каждого автономного объекта журнала, созданного `Logger`.
- `Handler`: интерфейс, который, будучи реализованным, определяет форматирование и назначение каждого `Record`. В пакет `log/slog` включены два встроенных обработчика: `TextHandler` и `JSONHandler` для вывода данных в формате `key=value` и JSON соответственно.

Как и большинство библиотек логирования в Go, пакет `slog` предоставляет стандартный `Logger`, доступный через функции верхнего уровня. Этот логер выводит почти такой же результат, как и старый метод `log.Printf()`.

Можно создать собственный экземпляр `Logger` с помощью метода `slog.New()`. Он принимает реализацию интерфейса `Handler`, который определяет, как будут отформатированы журналы и куда они будут записаны.

Вот пример, использующий встроенный тип `JSONHandler` для вывода JSON-логов в `stdout`:

```go
func main() {
	logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
	logger.Debug("Debug message")    
	logger.Info("Info message")    
	logger.Warn("Warning message")    
	logger.Error("Error message")
}
```

```cmd
{"time":"2023-03-15T12:59:22.227408691+01:00","level":"INFO","msg":"Info message"}
{"time":"2023-03-15T12:59:22.227468972+01:00","level":"WARN","msg":"Warning message"}
{"time":"2023-03-15T12:59:22.227472149+01:00","level":"ERROR","msg":"Error message"}
```

## Настройка логера по умолчанию

Самый простой способ настроить стандартный `Logger` — использовать метод `slog.SetDefault()`, позволяющий заменить стандартный логер на собственный.

```go
func main() {    
	logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))  
	slog.SetDefault(logger)    
	slog.Info("Info message")
}
```

Использование метода `SetDefault()` также изменяет стандартный `log.Logger`, используемый пакетом `log`. Такое поведение позволяет существующим приложениям, использующим старый `log`, плавно перейти к структурированному логированию.

## Добавление контекстных атрибутов в записи журнала

Существенным преимуществом структурированного логирования по сравнению с неструктурированными форматами является возможность добавления произвольных атрибутов в виде пар ключ/значение в записи журнала.

Эти атрибуты предоставляют дополнительный контекст о зарегистрированном событии. Это может быть полезно для таких задач, как устранение неполадок, генерация метрик, аудит и других целей.

```go
logger.Info(  
  "incoming request",  
  "method", "GET",  
  "time_taken_ms", 158,  
  "path", "/hello/world?q=search", 
   "status", 200,  
   "user_agent", "Googlebot/2.1 (+http://www.google.com/bot.html)",
   )
```

```
{
  "time":"2023-02-24T11:52:49.554074496+01:00",
  "level":"INFO",
  "msg":"incoming request",
  "method":"GET",
  "time_taken_ms":158,
  "path":"/hello/world?q=search",
  "status":200,
  "user_agent":"Googlebot/2.1 (+http://www.google.com/bot.html)"
}
```

Другой способ - использовать [сильно типизированные контекстные атрибуты](https://pkg.go.dev/log/slog#Attr), как показано ниже:

```go
logger.Info(  
  "incoming request",  
  slog.String("method", "GET"),  
  slog.Int("time_taken_ms", 158),  
  slog.String("path", "/hello/world?q=search"),  
  slog.Int("status", 200),  
  slog.String(    
    "user_agent",    
    "Googlebot/2.1 (+http://www.google.com/bot.html)",  
  ),
)
```

Чтобы гарантировать безопасность типов при добавлении контекстных атрибутов к записям, вы должны использовать метод `LogAttrs()` следующим образом:

```go
logger.LogAttrs(  
  context.Background(),  
  slog.LevelInfo,  
  "incoming request",  
  slog.String("method", "GET"),  
  slog.Int("time_taken_ms", 158),  
  slog.String("path", "/hello/world?q=search"),  
  slog.Int("status", 200),  
  slog.String(    
	"user_agent",    
	"Googlebot/2.1 (+http://www.google.com/bot.html)",  ),)
```

Slog также позволяет группировать несколько атрибутов под одним именем, но вывод зависит от используемого хендлера. Например, при использовании `JSONHandler` каждая группа вложена в объект JSON:

```go
logger.LogAttrs(  
  context.Background(),  
  slog.LevelInfo,  
  "image uploaded",  
  slog.Int("id", 23123),  
  slog.Group("properties",    
    slog.Int("width", 4000),    
    slog.Int("height", 3000),    
    slog.String("format", "jpeg"),  ),)
```

## Создание и использование дочерних логеров

Иногда может быть полезно включать одни и те же атрибуты во все записи в определённой области. Это будет гарантировать их наличие без повторяющихся операторов записи в лог.

Здесь на помощь приходят дочерние логеры. Они создают новый контекст логирования, который наследуется от родительского логера, и при этом позволяют включать дополнительные поля.

В Slog создание дочерних логеров осуществляется с помощью метода `Logger.With()`. Он принимает одну или несколько пар ключ/значение и возвращает новый `Logger`, который включает указанные атрибуты.

```go
func main() {    
  handler := slog.NewJSONHandler(os.Stdout, nil)    
  buildInfo, _ := debug.ReadBuildInfo()   

  logger := slog.New(handler)    
  
  child := logger.With(        
    slog.Group("program_info",            
    slog.Int("pid", os.Getpid()),            
    slog.String("go_version", buildInfo.GoVersion),        
    ),   
  )    
  . . .
}
```

Если такая конфигурация задана, то все записи, созданные логером `child`, будут содержать указанные атрибуты в свойстве `program_info`, пока оно не будет переопределено в точке логирования.

```go
func main() {    
  . . .    
  child.Info("image upload successful", 
	  slog.String("image_id", "39ud88"))    
  
  child.Warn("storage is 90% full",        
	  slog.String("available_space", "900.1 mb"))
}
```

```
{
  "time": "2023-02-26T19:26:46.046793623+01:00",
  "level": "INFO",
  "msg": "image upload successful",
  "program_info": {
    "pid": 229108,
    "go_version": "go1.20"
  },
  "image_id": "39ud88"
}
{
  "time": "2023-02-26T19:26:46.046847902+01:00",
  "level": "WARN",
  "msg": "storage is 90% full",
  "program_info": {
    "pid": 229108,
    "go_version": "go1.20"
  },
  "available_space": "900.1 MB"
}
```

Вы также можете использовать метод `WithGroup()` для создания дочернего логера, который запускает группу. В этом случае все атрибуты, добавленные к логеру (включая те, которые добавлены в точке логирования), будут вложены под именем группы.

```go
handler := slog.NewJSONHandler(os.Stdout, nil)
buildInfo, _ := debug.ReadBuildInfo()
logger := slog.New(handler).WithGroup("program_info")

child := logger.With(  
  slog.Int("pid", os.Getpid()),  
  slog.String("go_version", buildInfo.GoVersion),
)
  
  child.Warn(  
    "storage is 90% full",  
    slog.String("available_space", "900.1 MB"),
)
```

```
{
  "time": "2023-05-24T19:00:18.384136084+01:00",
  "level": "WARN",
  "msg": "storage is 90% full",
  "program_info": {
    "pid": 1971993,
    "go_version": "go1.20.2",
    "available_space": "900.1 mb"
  }
}
```

## Настройка уровней Slog

Пакет `log/slog` предоставляет четыре уровня логирования по умолчанию, каждый из которых связан с целочисленным значением: `DEBUG` (-4), `INFO` (0), `WARN` (4) и `ERROR` (8).

Если вам нужны собственные уровни, помимо тех, что Slog предоставляет по умолчанию, вы можете создать их через [интерфейс Leveler](https://pkg.go.dev/log/slog#Leveler), сигнатура которого выглядит следующим образом:

```go
type Leveler interface {    
	Level() Level
}
```

## Создание пользовательских обработчиков

Поскольку `Handler` — это интерфейс, можно создавать собственные обработчики для различного форматирования журналов или записи их в другие места.

Его сигнатура выглядит следующим образом:

```go
type Handler interface {   
	Enabled(context.Context, Level) bool    
	Handle(context.Context, r Record) error    
	WithAttrs(attrs []Attr) Handler    
	WithGroup(name string) Handler
}
```

Вот что делает каждый из методов:

- `Enabled()` определяет, следует ли обрабатывать или выбрасывать запись журнала в зависимости от ее уровня. Для принятия решения также может использоваться `context`.
- `Handle()` обрабатывает каждую запись журнала, отправленную обработчику. Она вызывается только в том случае, если `Enabled()` возвращает `true`.
- `WithAttrs()` создает новый обработчик из существующего и добавляет в него указанные атрибуты.
- `WithGroup()` создает новый обработчик из существующего и добавляет в него указанное имя группы так, чтобы это имя квалифицировало последующие атрибуты.

## Логирование ошибок с помощью Slog

Для типа `error` не предоставляется хелпер, как в большинстве фреймворков, поэтому вы должны использовать `slog.Any()`, как это сделано здесь:

```go
err := errors.New("something happened")

logger.ErrorContext(ctx, "upload failed", slog.Any("error", err))
```

```
{
  "time": "2024-01-02T14:13:44.41886393+01:00",
  "level": "ERROR",
  "msg": "upload failed",
  "error": "something happened"
}
```


## Как скрывать поля с чувствительными данными с помощью интерфейса LogValuer

Интерфейс `LogValuer` позволяет стандартизировать вывод логов, указав, как должны записываться пользовательские типы.

Вот его сигнатура:

```go
type LogValuer interface {    
	LogValue() Value
}
```

Пример
```go
// implement the `LogValuer` interface on the User struct
func (u User) LogValue() slog.Value {    
	return slog.StringValue(u.ID)
}
```

Вы также можете сгруппировать несколько атрибутов следующим образом:

```go
func (u User) LogValue() slog.Value {    
	return slog.GroupValue(        
		slog.String("id", u.ID),        
		slog.String("name", u.FirstName+" "+u.LastName),    
	)
}
```

## Best practices для записи и хранения логов в Go:

После того как вы настроили Slog или предпочитаемый вами сторонний фреймворк для логирования, рекомендуем придерживаться следующих лучших практик:

**1. Стандартизируйте интерфейсы для логирования.** Интерфейс `LogValuer` позволяет стандартизировать способ логирования различных типов в приложении. Это обеспечит согласованное представление этих типов в логах по всему приложению. Кроме того эта стратегия поможет исключить утечку чувствительных данных из логов приложения.

**2. Добавляйте трассировку стека в логи ошибок.** С трассировкой будет намного легче определить, где возникла ошибка в кодовой базе и какой программный поток привёл к проблеме.

Slog в настоящее время не предоставляет встроенного способа добавления трассировки стека к ошибкам, но, как мы демонстрировали ранее, эту функциональность можно реализовать с помощью пакетов вроде [pkgerrors](https://github.com/pkg/errors) или [go-xerrors](https://github.com/MDobak/go-xerrors) с помощью пары вспомогательных функций.

**3. Проверяйте согласованность вызовов Slog.** Одним из главных недостатков API Slog является то, что он позволяет использовать два разных типа аргументов. Это может привести к несогласованности в кодовой базе. Кроме того, вы обеспечьте согласованнность в именах ключей (snake_case, camelCase и т. д.) или чтобы логирующие вызовы содержали аргумент context.

Линтер, подобный [sloglint](https://github.com/go-simpler/sloglint/releases), может помочь вам применить различные правила для Slog.

**4. Делайте централизацию логов, но сначала сохраняйте их в локальные файлы.** Обычно лучше отделять задачу записи логов от их отправки в централизованную систему управления логами. Запись логов в локальные файлы сначала обеспечивает резервную копию на случай проблем с системой управления логами или сетью. Это может предотвратить возможную потерю важных данных.

**5. Делайте выгрузку выборок из логов.** Выгрузка выборок из логов (log sampling) — это практика записи только наиболее репрезентативных записей логов вместо всех событий. Этот метод полезен в средах с высокой нагрузкой, когда системы генерируют большие объёмы данных логов, и обработка каждого события может быть дорогостоящей.

**6. Используйте систему управления логами.** Когда логи централизованы в системе управления, становится легко искать, анализировать и отслеживать поведение приложения на нескольких серверах и в разных окружениях. Когда все логи в одном месте, значительно ускоряется способность идентифицировать и диагностировать проблемы, так как больше не нужно переключаться между разными серверами, чтобы собрать информацию о сервисе.