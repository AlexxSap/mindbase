источник https://habr.com/ru/articles/497994/

Escape analysis — это процесс, который компилятор использует для определения размещения значений, созданных вашей программой. В частности, компилятор выполняет статический анализ кода, чтобы определить, может ли значение быть помещено в стековый фрейм для функции, которая его строит, или значение должно «сбежать» в кучу. В Go нет ни одного ключевого слова или функции, которую вы могли бы использовать, чтобы указать компилятору какое решение ему принять. Только то, как вы пишете свой код, условно позволяет повлиять на это решение.

### Кучи
  
Куча — это вторая область памяти, помимо стека, используемая для хранения значений. Куча не самоочищается, как стеки, поэтому использование этой памяти обходится дороже. Прежде всего, затраты связаны со сборщиком мусора (GC), который должен содержать эту область в чистоте. Когда GC запускается, он будет использовать 25% доступной мощности вашего процессора. Кроме того, он может потенциально создавать микросекунды задержки «stop the world». Преимущество наличия GC заключается в том, что вам не нужно беспокоиться об управлении памятью кучи, которая исторически была сложной и подвержена ошибкам.

## Механика побега

Каждый раз, когда значение разделяется вне области стекового фрейма функции, оно помещается (или аллоцируется) в кучу. Задача алгоритмов escape analysis заключается в том, чтобы находить такие ситуации и поддерживать уровень целостности в программе. Целостность заключается в обеспечении того, чтобы доступ к любому значению всегда был точным, последовательным и эффективным.

Первая версия функция использует семантику значения при возврате
```go
func createUserV1() user {
     u := user{
        name:  "Bill",
        email: "bill@ardanlabs.com",
    }

    println("V1", &u)
    return u
}
```

Во второй версии функции для возврата используется семантика указателя
```go
func createUserV2() *user {
     u := user{
         name:  "Bill",
         email: "bill@ardanlabs.com",
     }

     println("V2", &u)
     return &u
}
```
Вместо передачи копии значения обратно в стек вызовов передается копия адреса для значения.

Здесь escape analysis и начинает поддерживать целостность. В этом случае компилятор определит, что небезопасно создавать значение типа user внутри стекового фрейма createUserV2, поэтому вместо этого он создаст значение в куче. Это произойдет сразу во время конструкции
```go
	u := user{
         name:  "Bill",
         email: "bill@ardanlabs.com",
     }
```

### Читаемость

Функция имеет прямой доступ к памяти внутри своего фрейма через указатель фрейма, но доступ к памяти вне фрейма требует косвенного доступа. Это означает, что доступ к значениям, которые попадают в кучу, также должен осуществляться косвенно через указатель.

### Отчетность компилятора

Чтобы увидеть решения, принимаемые компилятором, вы можете попросить компилятор предоставить отчет. Все, что вам нужно сделать, это использовать ключ -gcflags с опцией -m при вызове go build.  
  
_На самом деле вы можете использовать 4 уровня -m, но после 2 уровня информации становится слишком много. Я буду использовать 2 уровня -m._